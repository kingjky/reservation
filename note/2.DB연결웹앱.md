# 0. Hello!

## DB연결 웹 애플리케이션 소개

### 학습 목표

1. JavaScript의 기본문법을 이해한다.
2. DOM, Browser Event, Ajax이 각각 무엇인지 이해하고, 이를 활용해 웹화면을 제어할 수 있다.
3. JSP의 라이프사이클을 이해하고 redirect & forward 와 scope를 이해하고 사용할 수 있다. 
4. JSTL과 EL을 사용할 수 있다. 
5. 데이터베이스를 설치하고 간단한 SQL을 사용할 수 있다. 
6. Maven을 이해하고 Maven을 이용한 웹 어플리케이션을 작성할 수 있다. 
7. JDBC 프로그래밍을 할 수 있다. 
8. Web API를 이해한다. 

### 학습하기

#### Backend

- Database 이용
  - MySQL 사용
  - DB접근 및 CRUD 작업
  - Spring JDBC 사용
- Servlet, JSP
  - JSP는 Servlet으로 변환되어 실행된다
  - forward, redirect, 4개의 scope, JSP의 내장 객체 등

#### Frontend

- JavaScript
  - DOM, Event, Ajax



# 1. JavaScript - FE

## 1) 자바스크립트 변수-연산자-타입

### 학습 목표

1. 자바스크립트 변수 선언, 연산자 사용, Type을 이해한다.

### 핵심 개념

- 변수선언
- 연산자
- Type 종류
- Type 확인 방법

### 학습하기

[영상보강]
&&를 좀더 알아보겠습니다.
퀴즈! 이것의 결과는 무엇일까요?
\> var result = false && true;
한번씩 해보세요!
이 코드에서 알 수 있듯이 &&연산자는 모든 값이 true인지를 확인하지만, 첫번째가 이미 false라면 그 이후의 값은 확인할 필요가 없습니다. 똑똑한 자바스크립트 엔진은 그렇게 동작합니다.

**자바스크립트의 버전**

- 자바스크립트 버전은 ECMAScript(줄여서ES)의 버전에 따라서 결정되고, 이를 자바스크립트 실행 엔진이 반영합니다.
- ES5, ES6(ES2015).. 이런 식으로 버전을 일컫습니다.
- 2018년을 중심으로 ES6를 지원하는 브라우저가 많아서 몇 년간 ES6 문법이 표준으로 쓰이고 있습니다.
- ES6는 ES5문법을 포함하고 있어 하위호환성 문제가 없습니다.
- 다만 feature별로 지원하지 않는 브라우저가 있을 수 있어 조심해야 합니다.


**변수**

변수는 var, let, const 로 선언할 수 있습니다.

어떤 것을 사용하는가에 의해서 scope, 즉 변수의 유효범위가 달라집니다.

ES6이전까지는 var를 사용해서 변수를 선언할 수 있습니다.

```javascript
var a = 2;
var a = "aaa";
var a = 'aaa';
var a = true;
var a = [];
var a = {};
var a = undefined;
```


**연산자**

연산자 우선순위를 표현하기 위해서는 ()를 사용하면 됩니다. 

수학연산자는 +,-,*,/,%(나머지) 등이 있습니다.

그리고 논리 연산자, 관계연산자, 삼항연산자도 있습니다. 

```javascript
//or 연산자 활용
const name = "crong";
const result = name || "codesquad";
console.log(result);
var name = "";
var result = name || "codesquad";
console.log(result);
```


**연산자 - 삼항연산자**

간단한 비교와 값 할당은 삼항연산자를 사용할 수 있습니다.

```javascript
const data = 11;
const result = (data > 10) ? "ok" : "fail";
console.log(result);
```


**연산자 - 비교연산자**

비교는 == 보다는 ===를 사용한다.

==로 인한 다양한 오류 상황이 있는데 아래 결과를 참고해봅시다. 

```javascript
0 == false;
"" == false;
null == false;
0 == "0";
null==undefined;
```


**자바스크립트의 Type**

자바스크립트 타입에는 다양한 것이 존재합니다.

```javascript
> undefined, null, boolean, number, string, object, function, array, Date, RegExp
```

타입은 선언할 때가 아니고, <u>실행타임에 결정됩니다.</u> **(Dynamic Type)**

함수안에서의 파라미터나 변수는 실행될 때 그 타입이 결정됩니다. 

타입을 체크하는 또렷한 방법은 없습니다.

정확하게는 **toString.call 함수**를 이용해서 그 결과를 매칭하곤 하는데, 문자, 숫자와 같은 자바스크립트 기본 타입은 'typeof' 키워드를 사용해서 체크할 수 있습니다. 

배열은 타입을 체크하는 isArray함수가 표준으로 생겼습니다.

IE와 같은 구 브라우저를 사용해야 한다면 지원범위를 살펴보고 사용해야 합니다.

## 2) 자바스크립트 비교-반복-문자열

### 학습 목표

1. 분기, 반복문을 다룬다.
2. 간단한 자바스크립트 문자열 조작(parsing)을 할 수 있다.

### 핵심 개념

- If
- switch
- for
- while
- String replace메서드

### 학습하기



[영상보강]
영상의 6:42 부분의 반대로 반복문을 동작시키는(reverse iteration이라고 함) 경우가 실제 브라우저에서 얼마나 성능차이가 있을까요? 현대의 자바스크립트 엔진은 최적화를 통해 반복문을 최대한 빠르게 처리하는 과정을 거쳐왔습니다. 실제로 실험을 해보면 그 차이가 미미하다는 것을 알게 될 것입니다. 따라서 for문을 무조건 반대로 구현할 필요는 없습니다. 이런 상황이외에도 자바스크립트의 구현방법에 따라 (for 가 빠를까 while 빠를까? 등) 성능차이는 그리 크지 않습니다. 일반적으로는 코드의 가독성에 좀더 우선집중하는 게 좋습니다.

**비교문**

if , else if, else 를 통해서 다양한 비교문을 사용할 수 있습니다. 

[MDN 링크 바로가기](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#조건문)

```javascript
var a = true;
var result = (a) ? "ok" : "not ok";
console.log(result); // ok

var a = "something";
var result = (a) ? "ok" : "not ok";
console.log(result); // ok
```



**분기 - switch** 

로직을 분기하기 위해서 if문 이외에도 switch 문을 통해서도 해결할 수 있습니다. 

[MDN 링크 바로가기](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#switch문)

```javascript
switch (fruittype) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
    console.log("Mangoes are $0.56 a pound.");
    break;
  case "Papayas":
    console.log("Mangoes and papayas are $2.79 a pound.");
    break;
  default:
   console.log("Sorry, we are out of " + fruittype + ".");
}
console.log("Is there anything else you'd like?");
```



**반복**
for 문이나 while문을 사용해서 반복문을 구현할 수 있습니다.

```javascript
function howMany(selectObject) {
  var numberSelected = 0;
  for (var i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}
```

배열의 경우 forEach와 같은 메서드도 있고, for-of를 통한 탐색도 자주 사용됩니다.

(for-in은 객체를 탐색할때 사용합니다)

forEach와 같은 메서드의 사용법이 익숙하지 않다면, 우선은 for문으로 배열을 탐색하는 것으로 충분합니다.

[MDN 링크 바로가기](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Loops_and_iteration#for_문)

 ```javascript
const obj = ['a', 'b', 'c', 'd', 'e'];
// for...in
for(var i in obj){
	console.log(i);
}
// 0
// 1
// 2
// 3
// 4
 ```

```js
const obj = ['a', 'b', 'c', 'd', 'e'];
// for...of
for(var i of obj){
	console.log(i);
}
// a
// b
// c
// d
// e
```

```javascript
const obj = ['a', 'b', 'c', 'd', 'e'];
obj.forEach(i => {
	console.log(i);
});
// a
// b
// c
// d
// e
```



**문자열 처리**

자바스크립트의 문자와 문자열은 같은 타입으로 모두 문자열입니다.

```javascript
typeof "abc";  //string
typeof "a";    //string
typeof 'a';    //string. single quote도 사용가능.
```

문자열에 다양한 메서드가 있습니다.

```javascript
"ab:cd".split(":"); //["ab","cd"]
"ab:cd".replace(":", "$"); //"ab$cd"
" abcde  ".trim();  //"abcde"
```



### 참고 자료

MDN사이트에서 자바스크립트 문법의 예제들이 좋습니다.

그외에 자바스크립트 문법을 볼 수 있는 자료들이 온라인에 풍부합니다.

이를 통해 학습을 좀 더 해보세요.

## 3) 자바스크립트 함수

### **학습 목표**

1. 자바스크립트의 선언방식들과 그 차이점, 반환값, hoisting을 이해한다.

### **핵심 개념**

- Function
- Hoisting
- arguments
- 기본 반환값 (undefined)

### 학습하기

**함수 - 함수의 선언**

**함수는 여러 개의 인자를 받아서, 그 결과를 출력합니다.** 

파라미터의 개수와 인자의 개수가 일치하지 않아도 오류가 나지 않습니다. 

만약, 파라미터 1개가 정의된 함수를 부를 때, 인자의 개수를 0개만 넣어 실행하면, 이미 정의된 파라미터(매개변수)는 undefined이라는 값을 갖게 됩니다.

이는 변수는 초기화됐지만, 값이 할당되지 않았기 때문입니다.

이를 한번 테스트해보세요.

```javascript
// 함수의 호출.
function printName(firstname) {
    var myname = "jisu";
    return myname + " " +  firstname;
}
```

위와 같은 형식의 함수 선언코드는 함수선언문이라고 합니다. 

**함수 - 함수표현식 (Function Expression)**

함수는 아래 printName과 같이 표현할 수도 있습니다.

이렇게 표현하면 함수선언문과 달리 선언과 호출순서에 따라서 정상적으로 함수가 실행되지 않을 수 있습니다.

```javascript
function test() { 
    console.log(printName()); 
    var printName = function() {
        return 'anonymouse';
    }
}

test();
//TypeError: printName is not a function
```

함수 표현식보다 함수 선언문을 더 자주 사용하지만, 어떤 코딩컨벤션에서는 함수 표현식을 권장하기도 합니다.

어떤 컨벤션을 갖던지 한가지만 정해서 사용하는 게 좋습니다.


**함수 - 표현식과 호이스팅(Hoisting )**

앞선 코드에서, printName이 "printName이 is not defined" 이라고 오류가 나오지 않고, function이 아니라고 나온 이유는
printName이 실행되는 순간 'undefined'으로 지정됐기 때문입니다.

자바스크립트 함수는 실행되기 전에 함수 안에 필요한 변수값들을 미리 다 모아서 선언합니다.

함수 안에 있는 변수들을 모두 끌어올려서 선언한다고 해서, 이를 hoisting이라고 합니다.
(실제로 코드가 끌어올려지는 건 아니며<이 과정이 눈에 보이는 게 아니죠>, 자바스크립트 파서 내부적으로 그렇게 끌어올려서 처리하는 것입니다)

따라서 아래 코드 역시 함수를 값으로 가지지만 어쨌든 printName도 변수이므로 끌어올려지고, 값이 할당되기 전에 실행됐으므로 undefined가 할당된 상태입니다.

```javascript
printName(); //아직, printName이 undefined으로 할당된 상태다. 
var printName = function(){}
```

printName이라는 변수가 존재하고 아직 값이 할당되기 전이므로 printName에는 'undefined'이라는 기본 값이 할당된 셈입니다.

**함수 - 반환값과 undefined**

아래 함수의 반환값은 무엇일까요? 

```javascript
function printName(firstname) {
    var myname = "jisu";
    var result = myname + " " +  firstname;
}
```

정답은 undefined입니다.

자바스크립트 함수는 반드시 return값이 존재하며, 없을 때는 기본 반환값인 'undefined'가 반환됩니다.

자바스크립트에서는 void 타입이 없습니다. 



**함수 - arguments 객체**

함수가 실행되면 그 안에는 arguments라는 특별한 지역변수가 자동으로 생성됩니다.

arguments의 타입은 객체 입니다.(console.log( typeof arguments) 로 확인해보세요!)

자바스크립트 함수는 선언한 파라미터보다 더 많은 인자를 보낼 수도 있습니다.

이때 넘어온 인자를 arguments로 배열의 형태로 하나씩 접근할 수가 있습니다.

arguments는 배열타입은 아닙니다.

따라서 배열의 메서드를 사용할 수가 없습니다.

```javascript
function a() {
 console.log(arguments);
}
a(1,2,3);
//[Arguments] { '0': 1, '1': 2, '2': 3 }
```

자바스크립트의 가변인자를 받아서 처리하는 함수를 만들때 등에서 arguments속성을 유용하게 사용할 수가 있습니다.

**응용해보기**

- arguments속성을 사용해서 , 1~무한대까지 인자를 받아 합을 구하는 함수를 만들어봅시다.



### **생각해보기**

1. arrow function

ES2015에는 arrow function이 추가됐다.

[arrow function 참고 바로가기](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

간단하게 함수를 선언할 수 있는 문법으로 처음에는 꽤 낯설수 있습니다.

하지만 점점 많이 사용되고 있는 syntax이므로 같이 알아두어도 좋을 것 같습니다.

```javascript
function getName(name) {
   return "Kim " + name ;
}

//위 함수는 아래 arrow함수와 같다.
var getName = (name) => "Kim " + name;
```

## 4) 자바스크립트 함수 호출 스택

### **학습 목표**

1. 자바스크립트의 call stack을 이해합니다.

### **핵심 개념**

- call stack

### 학습하기

**함수 호출**

자바스크립트 함수 호출은 이렇게 불려집니다. 

이 함수를 실행해보세요.

run이 호출되고 그 다음에 printName이 호출됩니다.

```javascript
// 함수의 호출.
function printName(firstname) {
    var myname = "jisu";
    return myname + " ," +  firstname;
}

function run(firstname) {
   firstname = firstname || "Youn";
   var result = printName(firstname);
   console.log(result);
}
```



**함수호출과 stack**

아래 그림을 마우스로 클릭해서, 내용이 변경되는 것을 차분히 이해해보세요.

한 번에 보기 어렵다면 여러 번 돌려보며 이해해보세요. 

[![img](https://cphinf.pstatic.net/mooc/20180126_83/1516946077823AvIcy_GIF/2-1-4-1____.gif?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16696/#)

- **함수 호출 스택**

  출처 https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec

```javascript
function foo(b){
    var a = 5;
    return a * b + 10;
} 

function bar(x){
    var y = 3;
    return foo(x * y);
}

console.log(bar(6));
```

함수 호출 관계는 다음과 같습니다.

bar() → foo()

메모리에서는 우측의 Call Stack에서와같이 순서대로 쌓이게 됩니다.

bar 함수에서 foo를 호출한 후 foo 함수의 결과를 받아올 때까지 bar함수는 메모리 공간에서 사라지지 못하고 기다리고 있는 것이죠.

이를 당연히 생각할 수 있습니다.

foo의 경우에는 실행이 끝나고 return문이 실행되면 메모리 공간에서 사라집니다.

다시 말해서 Call Stack에서 없어지는 것이죠. 

call stack은 이렇게 동작하지만, 함수를 연속적으로 계속 호출하면 call stack이 꽉 차버리면서 더 실행되지 못하고 오류가 발생할 겁니다.

브라우저에서는 대부분 지정된 횟수만큼만 call stack을 쌓게 미리 설정해둔 경우가 많다고 합니다.

따라서 혹시 개발 중에 **Maximum call stack size exceeded** 오류를 발견해도 너무 놀라지 말고, 대처하도록 하세요.

 ### **생각해보기**

1. 여러분들이 구글 검색창에 'javascript call stack'을 찾아서 노출되는 글을 살펴봅니다.
2. 함수를 연속적으로 호출하는 샘플코드를 꼭 직접 구현해보고, 크롬 개발자도구의 콘솔창에서 실행한 후에, source탭에서 call stack을 확인해보세요.

# 2. WEB UI 개발 - FE

## 1) window 객체(setTimeout)

### **학습 목표**

1. setTimeout을 필요한 곳에 사용할 수 있다.
2. 비동기가 무엇인지 기본개념을 이해한다.

### **핵심 개념**

- setTimeout과 비동기

### 학습하기

- **window 객체와 setTimeout**

  영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다. 

[영상보강] 1:46 콜백함수는 callback 함수라고 합니다. 보통은 즉시 실행되지 않고, 나중에 필요한 시점에 실행되거나, 실행이 안 될 수도 있습니다. callback의 의미를 단어에서 좀 더 유추해보면 호출한 (call) 대상에서 되부름 (call back)되기 때문에 callback이라고 합니다. 실제로 callback 함수를 전달받은 쪽의 필요에 따라 즉시 실행될 수도 있답니다. ( ex> array.map(callback) ) 

**window 객체**

브라우저 개발을 하다 보면, window라는 객체가 있습니다.

window에는 많은 메서드들이 존재하며, 아래처럼 사용할 수 있습니다.

window는 디폴트의 개념이므로 생략할 수 있습니다.

```javascript
window.setTimeout()
setTimeout() //window는 전역객체라서 생략 가능하다.
```



**setTimeout 활용**

setTimeout은 낯설게 동작합니다.

인자로 함수를 받고 있으며, 보통 나중에 실행되는 함수를 콜백함수라고도 합니다.

자바스크립트는 함수를 인자로 받을 수 있는 특징이 있습니다.

참고로 함수를 반환할 수도 있고요.

```javascript
function run() {
    setTimeout(function() {
        var msg = "hello codesquad";
        console.log(msg);  //이 메시지는 즉시 실행되지 않습니다.
    }, 1000);
}

run();
```

setTimeout의 특성을 잘 이해하고, 지연실행이 필요한 경우에 잘 활용하면 좋습니다.

**setTimeout 실행 순서**

setTimeout의 실행은 비동기(asynchronous)로 실행되어 동기적인 다른 실행이 끝나야 실행됩니다.

```javascript
function run() {
    console.log("start");
    setTimeout(function() {
        var msg = "hello codesquad";
        console.log(msg);  //이 메시지는 즉시 실행되지 않습니다.
    }, 1000);
    console.log("end");
}

run();
```

즉 setTimeout 안의 함수(콜백함수)는 run함수의 실행이 끝나고 나서, (정확히는 stack에 쌓여있는 함수의 실행이 끝나고 나서 실행됨) 실행됩니다.

디버거를 통해서 이를 스스로 직접 확인하는 것이 학습이 도움이 됩니다. 

```js
function run() {
    setTimeout(function() {
        var msg = "hello codesquad";
        console.log(msg);  //이 메시지는 즉시 실행되지 않습니다.
	}, 0);
	console.log("run function end");
}

run();
// run function end
// hello codesquad
```





### **생각해보기**

1. 자바스크립트 비동기 예제를 좀 더 찾아보세요. setTimeout 말고도 비슷하게 동작하는 것들이 무엇이 있는지 알아보세요.
2. setInterval이라는 메서드도 있습니다. 비슷한 동작인데 사용방법을 익혀두면 좋아요.

## 2) DOM과 querySelector

### **학습 목표**

1. DOM(Document Object Model)을 이해한다.

### **핵심 개념**

- DOM Tree
- DOM API
- querySelector

### 학습하기

- **DOM과 querySelector**

  영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

**1. DOM**

브라우저에서는 HTML코드를 DOM(Document Object Model)이라는 객체형태의 모델로 저장합니다. 

그렇게 저장된 정보를 DOM Tree라고 합니다.

결국 HTML element는 Tree 형태로 저장됩니다.

[![img](https://cphinf.pstatic.net/mooc/20180126_280/1516956194218XFPk5_PNG/2-2-2_Dom_tree.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16699/#)

- **Dom tree**

복잡한 DOM Tree를 탐색하기 위해 JavaScript로 탐색알고리즘을 구현하면 너무 힘듭니다.

그래서 브라우저에서는 DOM(document object model)이라는 개념을 통해서, 다양한 DOM API(함수 묶음정도)를 제공하고 있습니다.

브라우저는 DOM Tree찾고 조작하는 걸 쉽게 도와주는 여러 가지 메서드를(DOM API)를 제공합니다.



**2. getElementById()**

ID 정보를 통해서 찾을 수 있습니다.

MDN사이트를 참고해서 이를 테스트해봅시다.

테스트를 할 때는 특정 웹사이트에 접속한 후, 크롬 개발자도구-콘솔을 열어서 그곳에서 코딩을 해보면서 찾을 수 있습니다. 



**3 Element.querySelector()**

DOM을 찾는데 특히 유용한 querySelector 메서드입니다.

CSS 스타일을 결정할 때 사용하던, Selector 문법을 활용해 DOM에 접근할 수 있습니다.

DOM을 찾을 때 querySelector만 써도 충분하고 빠릅니다.

```js
document.querySelector("a");

document.querySelector("#exampleId");

document.querySelector(".exampleClass");

document.querySelector(".exampleClass > children");

document.querySelector(".exampleClass child");
```

참고로, 비슷하지만 다른 querySelectorAll이 있습니다. 

이 녀석은 어떤 역할을 하는지, 그 반환 값은 무엇인지 확인해보세요.

- 검색 조건을 만족하는 모든 Element를 `NodeList` 형태로 반환

특정 웹사이트에 접속한 후, 크롬 개발자도구를 열어 콘솔 창에서 querySelectorAll을 활용해서 다양한 UI 영역을 찾아보세요.



**4. css selector**

selector문법은 querySelector와 querySelectorAll메서드에서 사용할 수 있으며, css 스타일을 부여했을 때 익혔던 selector문법과 동일하다고 생각하고 사용할 수가 있습니다.

다양한 css selector문법을 사용해서 원하는 엘리먼트를 찾을 수 있습니다.



### **생각해보기**

1. 이번 기회에 다양한 CSS Selector 문법들을 좀 더 찾아보세요! 잘 쓸수록 막강합니다.
2. 여러분들이 즐겨 찾는 웹사이트에 접속해서 특정 UI 영역을 querySelector로 찾아보세요.
3. DOM 에서 훨씬 더 많은 함수가 존재합니다. DOM을 추가하고 삭제하고, 그리고 DOM을 탐색할 수 있는(위아래로 이동) 속성들도 있습니다. 궁금한 분들이 미리 찾아보세요.



## 3) Browser Event, Event object, Event handler

### **학습 목표**

1. Event listener 무엇인지 이해합니다.
2. Event객체를 사용할 수 있습니다.

### **핵심 개념**

- Event listener
- addEventListener
- event object

### 학습하기

- **Event와 Event 리스너**

  영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

**Event**

브라우저에는 많은 이벤트가 발생합니다.

브라우저 화면의 크기를 마우스로 조절할 때도, 스크롤을 할 때도, 마우스로 이동하거나 무언가를 선택할 때도 
이벤트가 발생합니다.

이벤트를 브라우저가 발생시켜주니, 우리는 그때 어떤 일을 하라고 할 일을 등록할 수가 있습니다.

다시 말해, HTML엘리먼트별로 어떤 이벤트(주로 키보드나 마우스 관련)가 발생했을 때 특정 행위를(어떤 일) 하고 싶다면, 대상엘리먼트를 찾고 어떤 일을 등록하면 된다.

그것을 자바스크립트로 구현할 수 있습니다.



**이벤트 등록**

이벤트 등록 표준방법입니다.

addEventListener 함수를 사용할 수 있습니다.

```javascript
var el = document.querySelector(".outside");
el.addEventListener("click", function(){
//do something..
}, false);
```

addEventListener 함수의 두 번째 인자는 함수입니다.

이 함수는 나중에 이벤트가 발생할 때 실행되는 함수로 이벤트핸들러(Event Handler) 또는 이벤트리스너(Event Listener)라고 합니다.

콜백함수는 이벤트가 발생할 때 실행됩니다. 



**이벤트 객체**

브라우저는 이벤트 리스너를 호출할 때, 사용자로부터 어떤 이벤트가 발생했는지에 대한 정보를 담은 이벤트 객체를 생성해서 리스너 함수에 전달합니다.

따라서 이벤트리스너 안에서는 이벤트객체를 활용해서 추가적인 작업을 할 수 있게 됩니다. 

```javascript
var el = document.getElementById("outside");
el.addEventListener("click", function(evt){
 console.log(evt.target);
 console.log(evt.target.nodeName);
}, false);
```

가장 많이 쓰이는 건 event.target입니다.

event.target은 이벤트가 발생한 element를 가리킵니다. 

element도 객체이므로 안에 nodeName이나 classname과 같이 element가 가진 속성을 사용할 수 있습니다.



### **생각해보기**

1. event type에는 어떤 것들이 있나요? 마우스, 키보드 관련 타입 들을 자세히 알아보세요.



## 4) Ajax통신의 이해

### **학습 목표**

1. Ajax기술은 왜 나왔고, 어떻게 사용하는지 이해한다.

### **핵심 개념**

- XMLHTTPRequest
- Ajax

### 학습하기

- **Ajax 통신의 이해**

  영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

 [영상보강] 02:33부분에서 '표준적인 데이터 포맷을 결정하기 위해서 주로 JSON(JavaScript Object Notation) 포맷을 사용' 이라고 표현되어 있는데요, 이부분 표현이 어색해서 오해하실 수 있을것 같네요. 데이터 포맷을 결정하기 위해서라면 JSON이 아니라 'HTTP Header'가 그 역할을 합니다. 물론 JSON 포맷은 Ajax를 위한 대표적인 포맷은 맞습니다. ^^

**1. Ajax (XMLHTTPRequest 통신, Asynchronous Javascript And Xml)**

이 기술은 웹에 데이터를 갱신할 때, 브라우저 새로고침 없이 서버로부터 데이터를 받는 것이 좋겠다는 생각에서 출발했습니다.

더 좋은 UX를 제공할 수 있는 기술입니다.

아래 탭 UI를 살펴봅시다.

상단에 탭을 누를때마다 컨텐츠가 달라집니다.

누르지도 않은 탭의 컨텐츠까지 초기로딩시점에 모두 불러온다면 초기로딩속도에 영향을 줄 것이다.

따라서 동적으로 필요한 시점에 컨텐츠를 받아와서 표현하면 더 좋습니다.

이 경우가 Ajax기술을 활용할 수 있는 대표적인 경우입니다.

[![img](https://cphinf.pstatic.net/mooc/20180127_24/1517019609588ClfFr_PNG/2-2-4_Ajax_.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16701/#)

- **Ajax통신의 이해**

Ajax 통신으로는 XML, Plain Text, JSON 등 다양한 포맷의 데이터를 주고받을 수 있지만, 일반적으로 사용이 편리한 JSON포맷으로 데이터를 주고 받습니다

JSON이 무엇인지 찾아보고, JSON 포맷으로 데이터를 작성하려면 어떤 규칙이 필요한지 알아보세요.

##### JSON(JavaScript Object Notation)

- Key: Value 형태

```json
 {
    "이름": "홍길동",
    "나이": 25,
    "성별": "여",
    "주소": "서울특별시 양천구 목동",
    "특기": ["농구", "도술"],
    "가족관계": {"#": 2, "아버지": "홍판서", "어머니": "춘섬"},
    "회사": "경기 수원시 팔달구 우만동"
 }
```





**2. AJAX 실행코드**

AJAX 실행 코드는 아래와 같습니다.

아래 방법은 XMLHTTPRequest 객체를 사용하는 표준방법입니다.

```javascript
function ajax(data) {
 var oReq = new XMLHttpRequest();
 oReq.addEventListener("load", function() {
   console.log(this.responseText);
 });    
 oReq.open("GET", "http://www.example.org/getData?data=data");//parameter를 붙여서 보낼수있음. 
 oReq.send();
}
```

[링크 바로가기](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest)

XMLHttpRequest객체를 생성해서, open메서드로 요청을 준비하고, send메서드로 서버로 보냅니다. 

요청처리가 완료되면(서버에서 응답이 오면) load이벤트가 발생하고, 콜백함수가 실행됩니다.

콜백함수가 실행될 때는 이미 ajax함수는 반환하고 콜스택에서 사라진 상태입니다. 

이는 setTimeout함수의 콜백함수의 실행과 유사하게 동작하는 '비동기'로직 입니다.

### **생각해보기**

1. Ajax는 비동기로 통신을 합니다. Ajax코드의 다양한 예제를 익혀보도록 해보세요.
2. 특히 post방식으로 데이터를 전송하는 방법도 공부해보면 좋습니다.
3. CORS라는 기술은 무엇인지도 살펴봅니다. 이 기술이 왜 나왔는지 이해하는게 중요합니다.

## 5) JavaScript Debugging

### **학습 목표**

1. 크롬브라우저를 통해서 자바스크립트 디버깅 방법을 알아본다.

### **핵심 개념**

- chrome developer tools
- debugging

### 학습하기

- **JavaScript Debugging**

  영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

**디버깅 컨트롤**

- Pause, Continue : 첫 번째 버튼은 평소에는 Pause 버튼 상태인데 브렉포인트가 잡힌 상태에선 Continue 버튼이 됩니다. 다른 브레이크포인트가 잡힐 때까지 코드를 진행합니다.
- Step over next function call : 스텝 오버는 코드 라인을 한 스탭 진행하는데 현재 실행 라인에 함수 실행 코드가 있다면 함수는 실행하는데 이때 함수 안의 코드로는 진입하지 않습니다. 즉 라인의 함수를 실행만 하게 됩니다.
- Step into next function call : 스텝 인투는 스텝 오버와 다르게 현재 실행 라인의 코드에 함수가 있다면 함수 안의 첫 번째 코드로 진입해 들어가 다시 하나씩 라인별로 코드를 실행할 수 있습니다.
- Step out of current function : 스텝 인투로 들어온 함수를 끝까지 실행하고 밖으로 빠져나와 해당 함수를 실행한 함수로 돌아갑니다.
- Active/Deactive breakpoint : 브레이크포인트를 끄거나 켤 수 있습니다.
- Pause on exception : 자바스크립트 예외가 발생하면 해당 위치에 브레이크포인트를 잡아줍니다.

### **생각해보기**

1. 본인이 개발 중 인코드의 디버깅을 지금 배운 내용으로 해봅니다. 디버깅을 통한 개발방법도 일종의 습관입니다.
2. 구글 검색창에 '크롬 개발자 도구 자바스크립트 디버깅'을 입력해서 학습해보세요.

# 3. JSP - BE

## 1) JSP란?

### **학습 목표**

1. jsp가 무엇인지 이해한다. 
2. jsp의 간단한 사용법을 알아본다. 

### **핵심 개념**

- jsp (java server page)

### 학습하기

- **jsp 란?**

  영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

**실습코드**

```html
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>sum10</title>
</head>
<body>

<% 
    int total = 0;
    for(int i = 1; i <= 10; i++){
        total = total + i;
    }
%>

1부터 10까지의 합 : <%=total %>

</body>
</html>
```

##### JSP

- JSP는 Servlet으로 변환되어 실행된다

- HTML 문서 내에 Java 코드를 삽입한다

  - #### **Scriptlet** : `<% %>`
  - #### 표현식 : `<%= 'abc' %>`
    
    => out.print('abc'); 변환

- ```jsp
  <%@ page language="java" contentType="text/html; charset=UTF-8"
  	pageEncoding="UTF-8"%>
  ```

  - language: 이론적으로 java 외 다른 언어도 가능
    -> 실제론 java밖에 사용안함
  - contentType, pageEncoding



**JSP 등장 배경**

- 마이크로소프트에서 ASP(Active Server Page)라는 쉽게 웹을 개발할 수 있는 스크립트(script) 엔진을 발표함 (1998년
- 1997년에 발표된 서블릿은 ASP에 비하여 상대적으로 개발 방식이 불편함
- ASP에 대항하기 위하여 1999년 썬마이크로시스템즈에서 JSP를 발표
- JSP는 실제로 서블릿 기술을 사용



### **생각해보기**

1. 1부터 10까지의 합을 구하는 서블릿과 JSP를 비교해봤을 때 JSP가 어떤 부분에서 편리한것 같나요?

## 2) JSP 라이프싸이클

### **학습 목표**

1. jsp의 라이프 사이클을 이해한다. 
2. jsp를 이용해서 init, destroy 메소드를 이용할 수 있다. 

### **핵심 개념**

- jsp라이프 사이클

### 학습하기

- **jsp 라이프사이클**

  영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

1에서 10까지 출력하는 jsp가 서블릿으로 변경 된 파일입니다. 

```
eclipse-workspace\
.metadata\.plugins\org.eclipse.wst.server.core\tmp0\work\Catalina\localhost\
firstweb\org\apache\jsp
```



```java
public void _jspInit() {
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException {

    .....

    try {
      .....

      out.write("\n");
      out.write("<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n");
      out.write("<html>\n");
      out.write("<head>\n");
      out.write("<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n");
      out.write("<title>sum10</title>\n");
      out.write("</head>\n");
      out.write("<body>\n");
      out.write("\n");

	int total = 0;
	for(int i = 1; i <= 10; i++){
		total = total + i;
	}

      out.write("\n");
      out.write("\n");
      out.write("1부터 10까지의 합 : ");
      out.print(total );
      out.write("\n");
      out.write("\n");
      out.write("</body>\n");
      out.write("</html>");
    } catch (java.lang.Throwable t) {
      .....
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
```

스크립틀릿 부분이라고 java 코드를 입력한 부분은 다음과 같이 입력되어 있습니다.

```java
int total = 0;
for(int i = 1; i <= 10; i++){
    total = total + i;
}
```

표현식으로 출력한 부분은 다음과 같습니다.

```java
out.print(total );
```



**JSP의 실행순서**

1. 브라우저가 웹서버에 JSP에 대한 요청 정보를 전달한다.

2. Servlet엔진이 JSP에 해당하는 Servlet이 존재하는지 체크

   - 해당하는 Servlet이 없는 경우: (브라우저가 요청한 JSP가 최초로 요청했을 경우) JSP 엔진이

   1. JSP로 작성된 코드가 서블릿으로 코드로 변환한다. (java 파일 생성)
   2. 서블릿 코드를 컴파일해서 실행가능한 bytecode로 변환한다. (class 파일 생성)
   3. 서블릿 클래스를 로딩하고 인스턴스를 생성한다.

3. 서블릿이 실행되어 요청을 처리하고 응답 정보를 생성한다.



lifecycle.jsp

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
hello
<%
	System.out.println("_jspService()");
%>

<%!
public void jspInit() {
	System.out.println("jspInit()!");
}

public void jspDestroy() {
	System.out.println("jspDestroy()");
}
%>

</body>
</html>
```

- #### 선언식: `<%! %>`

- _jspInit: 최초 jsp를 Servlet으로 변환할 때 호출
- _jspService: 응답과 관련된 메소드를 모두 포함. jsp를 요청받을 때마다 호출됨
- _jspDestroy: jsp 내부에 변경사항이 있을 경우 기존 변환된 Servlet을 삭제 후 재 변환이 필요. 삭제될 때 호출

### **생각해보기**

1. 서블릿 라이프 싸이클에서 실행되는 메소드와 JSP 라이프 싸이클에서 실행되는 메소드의 이름을 비교해 봅시다.

   서블릿 라이프 싸이클에서 실행되는 메소드의 이름은 init(), service(), destroy()이고,

   JSP 라이프 싸이클에서 실행되는 메소드의 이름은 jspInit(), _jspService(), jspDestory()입니다.

## 3) JSP 문법

### **학습 목표**

1. JSP에서 선언문을 이용해 필드와 메소드를 선언할 수 있다.
2. JSP에서 자바 코드를 입력하는 방법을 알 수 있다.
3. JSP에서 변수값을 출력할 수 있다.
4. JSP에서 주석문을 작성할 수 있다.

### **핵심 개념**

- 선언문(Declaration)
- 스크립트릿(Scriptlet)
- 표현식(Expression) 
- 주석(Comment) 

### 학습하기

- **jsp 문법**

  영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

**스크립트 요소의 이해**

- JSP 페이지에서는 **<u>선언문(Declaration), 스크립트릿(Scriptlet), 표현식(Expression)</u>** 이라는 3가지의 스크립트 요소를 제공

[![img](https://cphinf.pstatic.net/mooc/20180130_100/1517276242978yRxDX_PNG/2_3_3___.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16704/#)

- **스크립트 요소의 이해**

 **선언문(Declaration)**

- 선언문 : <%! %>
- 선언문은 JSP 페이지 내에서 필요한 **<u>멤버변수나 메소드가 필요할 때 선언</u>**해 사용하는 요소
  - 작성된 내용이 _jspService가 아닌 class 내에 선언되는 유일한 스크립트 요소 
- 선언문의 문법
- <%! 문장 %>



exam1.jsp

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>

id : <%=getId() %>
</body>
</html>

<%!
    String id = "u001"; //멤버변수 선언
    public String getId( ) { //메소드 선언
        return id;
    }
%>
```



**스크립트릿(Scriptlet)**

- 스크립트릿 : <% %>
- 가장 일반적으로 많이 쓰이는 스크립트 요소
- 주로 **<u>프로그래밍의 로직을 기술</u>**할 때 사용
- 스크립트릿에서 선언된 변수는 지역변수
- 스크립트릿의 문법
- <% 문장%>


exam02.jsp

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>

<%
for(int i = 1; i <= 5; i++){
%>
<H<%=i %>> 아름다운 한글 </H<%=i %>>
<%
}
%>
</body>
</html>
```


html 소스보기 결과

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>


<H1> 아름다운 한글 </H1>

<H2> 아름다운 한글 </H2>

<H3> 아름다운 한글 </H3>

<H4> 아름다운 한글 </H4>

<H5> 아름다운 한글 </H5>

</body>
</html>
```

 

서블릿으로 변환된 코드 주요부분

```java
for(int i = 1; i <= 5; i++){

      out.write('\n');
      out.write('<');
      out.write('H');
      out.print(i );
      out.write("> 아름다운 한글 </H");
      out.print(i );
      out.write('>');
      out.write('\n');

}
```



**표현식(Expression)**

- 표현식 : <%=%>
- JSP 페이지에서 **<u>웹 브라우저에 출력할 부분</u>**을 표현 (즉, 화면에 출력하기 위한 것)
  - 응답할 내용
- 스크립트릿내에서 출력할 부분은 내장객체인 out 객체의 print() 또는 println() 메소드를 사용해서 출력
- 표현식의 문법
- <%=문장%>



**주석(Comment)**

- JSP페이지에서 사용할 수 있는 주석
- HTML주석, 자바 주석, JSP주석

 

1. HTML 주석

- HTML 주석은 <!--로 시작해서 -->로 끝나는 형태
- HTML 주석은 HTML주석을 사용한 페이지를 웹에서 서비스할 때 화면에 주석이 내용이 표시되지는 않으나 , [소스보기]수행하면 HTML주석의 내용이 화면에 표시.
  - 브라우져가 HTML을 해석하는 시점에 주석으로 무시된다.
- HTML주석의 예시

```markup
<!-- html 주석입니다. -->
```

2. JSP주석

- JSP 페이지에서만 사용되며 <%--로 시작해서 --%>로 끝나는 형태
- JSP 주석은 해당 페이지를, 웹 브라우저를 통해 출력 결과로서 표시하거나, 웹 브라우저 상에서 소스 보기를 해도 표시 되지 않음. 또한 JSP주석 내에 실행코드를 넣어도 그 코드는 실행되지 않음.
  - JSP 시점에 주석으로서 무시된다.
- JSP주석의 예시

```markup
<%-- JSP 주석입니다. --%>
```

3. 자바주석

- 자바 주석은 //, /**/을 사용해서 작성.
- //은 한 줄짜리 주석을 작성할 때 사용되고, /**/은 여러 줄의 주석을 작성할 때 사용
- 스크립트릿이나 선언문에서 사용되는 주석으로, 자바와 주석 처리 방법이 같음
  - JSP에서 Servlet으로 변환되어 실행되는 시점에 무시된다.
- 자바주석의 예시

```java
//주석

/*주석

여러 줄에 걸친 주석이다.

*/
```



**주석 실습코드**

```html
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<%-- jsp 주석문입니다.
여러줄을 입력할 수 있습니다. --%>
<!-- html 주석문입니다. -->
<%
/*
자바 여러줄 주석문입니다.
*/
for(int i = 1; i <= 5; i++){ // java 한줄 주석문입니다.
%>
<H<%=i %>> 아름다운 한글 </H<%=i %>>
<%
}
%>
</body>
</html>
```

### **생각해보기**

1. JSP는 서블릿 소스코드로 변환된다고 했습니다.
2. 이번 시간에 배웠던 JSP들이 서블릿 소스로 변환될 때 스크립틀릿, 표현식, 선언문이 어떻게 변환될지 예상해 봅시다.
   - Scriptlet: Service method 내부 코드
   - 표현식: Service method 내부 out.print 호출
   - 선언문: Service method 외부 Class 영역



## 4) JSP 내장객체

### **학습 목표**

1. 내장객체가 무엇인지 이해한다. 
2. 내장객체 종류를 알고 이용할 수 있다. 

### **핵심 개념**

- request 
- response
- out
- application
- page
- session

### **학습하기**

- **내장객체(Implicit Object)**

  영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

**JSP 내장 객체란?**

- JSP를 실행하면 서블릿 소스가 생성되고 실행된다.
- JSP에 입력한 대부분의 코드는 생성되는 서블릿 소스의 _jspService() 메소드 안에 삽입되는 코드로 생성된다.
- _jspService()에 삽입된 코드의 윗부분에 미리 선언된 객체들이 있는데, 해당 객체들은 jsp에서도 사용 가능하다.
- response, request, application, session, out과 같은 변수를 내장객체라고 한다.



**내장 객체의 종류**

[![img](https://cphinf.pstatic.net/mooc/20180130_74/1517275973733EL11k_PNG/2_3_4_jsp_.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/19882/#)

- **내장 객체의 종류**

### **실습코드**

- 내장객체를 사용하는 간단한 예제를 작성해 보도록 하겠습니다.
- ImplicitObjects.jsp 를 작성해보도록 하겠습니다.

 

ImplicitObjects.jsp

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<%
    StringBuffer url = request.getRequestURL();

    out.println("url : " + url.toString());
    out.println("<br>");
%>
</body>
</html>
```



ImplicitObjects_jsp.java

```java
  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException {

    ......

    javax.servlet.jsp.JspWriter _jspx_out = null;

    ......

    out = pageContext.getOut();
    ......


        StringBuffer url = request.getRequestURL();

        out.println("url : " + url.toString());
        out.println("<br>");
```

### **생각해보기**

1. 내장객체를 JSP 선언문에서 사용할 수 있을까요? 사용할 수 없다면 왜 그럴까요?

   Implicit Objects는 _jspService method 내부에 선언된 local variable이며 JSP 선언문은 _jspService method 외부의 Class 영역에 정의되는 부분이기 때문에 variable scope가 일치하지 않으므로 사용이 불가하다.



# 4. redirect & forward - BE

## 1) redirect

### **학습 목표**

1. 리다이렉트를 이해한다. 
2. 리다이렉트를 사용 할 수 있다. 

### **핵심 개념**

- HttpServletResponse 
- sendRedirect() 



### 학습하기

- **redirect**

  영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

**리다이렉트 (redirect)**

- 리다이렉트는 HTTP프로토콜로 정해진 규칙이다.
- 서버는 클라이언트의 요청에 대해 특정 URL로 이동을 요청할 수 있다. 이를 리다이렉트라고 한다.
- 서버는 클라이언트에게 HTTP 상태코드 302로 응답하는데 이때 헤더 내 Location 값에 이동할 URL 을 추가한다. 클라이언트는 리다이렉션 응답을 받게 되면 헤더(Location)에 포함된 URL로 재요청을 보내게 된다. 이때 브라우저의 주소창은 새 URL로 바뀌게 된다..
- 클라이언트는 서버로부터 받은 상태 값이 302이면 Location헤더값으로 재요청을 보내게 된다. 이때 브라우저의 주소창은 전송받은 URL로 바뀌게 된다.
- 서블릿이나 JSP는 리다이렉트하기 위해 HttpServletResponse 클래스의 sendRedirect() 메소드를 사용한다.

 

 

**브라우저에서 리다이렉트 확인**

- 크롬에서 우측버튼을 누르고 검사를 선택한 후 Network탭을 선택한다.
- redirect01.jsp를 실행하면 서버로부터 응답코드로 302를 받는 것을 알 수 있다.

[![img](https://cphinf.pstatic.net/mooc/20180226_92/1519624813885zKuOX_PNG/1.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/19878/#)

- **브라우저에서 리다이렉트 확인**

**예제 동작 설명**

[![img](https://cphinf.pstatic.net/mooc/20180127_5/1517046342330PRbSX_PNG/2_4_1_redirect__.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/19878/#)

- **예제 동작 설명**



### **실습코드**

- redirect01.jsp, redirect02.jsp 파일을 작성
- 웹 브라우저가 redirect01.jsp을 요청
- redirect01은 redirect02.jsp로 리다이렉팅하는 로직이 실행되도록 함
- 결과 확인

 

redirect01.jsp

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%
    response.sendRedirect("redirect02.jsp");
%>    
```

 

redirect02.jsp

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
redirect된 페이지 입니다.
</body>
</html>
```



### **생각해보기**

1. 리다이렉션의 장점과 단점에 대해서 알아봅시다.



## 2) forward

### **학습 목표**

1. foward를 이해한다. 
2. foward를 사용 할 수 있다.

### **핵심 개념**

- RequestDispatcher
- forward()



### **학습하기**

- **forward**

  영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

[![img](https://cphinf.pstatic.net/mooc/20180129_279/1517202070933x0x42_PNG/2_4_2_forward.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16705/#)

- **forward**

  출처 http://java.scwcd.jobs4times.com/Web-Container-Model.html

**forward란?**

1. 웹 브라우저에서 Servlet1에게 요청을 보냄
2. Servlet1은 요청을 처리한 후, 그 결과를 HttpServletRequest에 저장
3. Servlet1은 결과가 저장된 HttpServletRequest와 응답을 위한 HttpServletResponse를 같은 웹 어플리케이션 안에 있는 Servlet2에게 전송(forward)
4. Servlet2는 Servlet1으로 부터 받은 HttpServletRequest와 HttpServletResponse를 이용하여 요청을 처리한 후 웹 브라우저에게 결과를 전송



### **실습코드**

FrontServlet.java

```java
package examples;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class FrontServlet
 */
@WebServlet("/front")
public class FrontServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public FrontServlet() {
        super();
        // TODO Auto-generated constructor stub
    }

    /**
     * @see HttpServlet#service(HttpServletRequest request, HttpServletResponse response)
     */
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            
            int diceValue = (int)(Math.random() * 6) + 1; 
            request.setAttribute("dice", diceValue);
            
            RequestDispatcher requestDispatehcer = request.getRequestDispatcher("/next");
            requestDispatehcer.forward(request, response);
    }

}
```


NextSevlet.java

```java
package examples;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Enumeration;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ForwardServlet
 */
@WebServlet("/next")
public class ForwardServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public ForwardServlet() {
        super();
        // TODO Auto-generated constructor stub
    }

    /**
     * @see HttpServlet#service(HttpServletRequest request, HttpServletResponse response)
     */
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<html>");
        out.println("<head><title>form</title></head>");
        out.println("<body>");

        int dice = (Integer)request.getAttribute("dice");
        out.println("dice : " + dice);
        for(int i = 0; i < dice; i++) {
            out.print("<br>hello");
        }
        out.println("</body>");
        out.println("</html>");
    }

}
```



### **생각해보기**

- HttpServletRequest와 HttpServletResponse는 내부적으로 어떻게 다를까?
  - https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpServletRequest.html
  - https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpServletResponse.html

1. 서블릿은 프로그램 로직을 개발하기에 편리하지만, HTML 태그를 출력하기엔 불편합니다. JSP는 프로그램 로직을 개발하기는 좀 불편하지만, HTML 태그를 출력하기엔 편리합니다. 서블릿과 JSP는 서로 장단점이 반대입니다. 포워드를 이용해서 이러한 단점을 해결하고 싶습니다. 어떻게 해야 할까요?

## 3) servlet & jsp 연동

### **학습 목표**

1. 서블릿과 JSP를 적절히 이용해서 포워딩을 효율적으로 사용할 수 있다.

### **핵심 개념**

- forward
- request.setAttribute()
- request.getAttribute()

### 학습하기

- **servlet_jsp 연동**

  영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

**Servlet과 JSP연동**

- Servlet은 프로그램 로직이 수행되기에 유리하다. IDE 등에서 지원을 좀 더 잘해준다.
- JSP는 결과를 출력하기에 Servlet보다 유리하다. 필요한 html문을 그냥 입력하면 됨.
- 프로그램 로직 수행은 Servlet에서, 결과 출력은 JSP에서 하는 것이 유리하다.
- Servlet과 JSP의 장단점을 해결하기 위해서 Servlet에서 프로그램 로직이 수행되고, 그 결과를 JSP에게 포워딩하는 방법이 사용되게 되었다. 이를 Servlet과 JSP연동이라고 한다.



[![img](https://cphinf.pstatic.net/mooc/20180129_201/1517203743283AcQbB_PNG/2_4_3_servlet_jsp.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16706/#)

- **servlet jsp연동**



### **실습코드**

LogicServlet.java

```java
package examples;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class LogicServlet
 */
@WebServlet("/logic")
public class LogicServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public LogicServlet() {
        super();
        // TODO Auto-generated constructor stub
    }

    /**
     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        int v1 = (int)(Math.random() * 100) + 1;
        int v2 = (int)(Math.random() * 100) + 1;
        int result = v1 + v2;
        
        request.setAttribute("v1", v1);
        request.setAttribute("v2", v2);
        request.setAttribute("result", result);
        
        RequestDispatcher requestDispatcher = request.getRequestDispatcher("/result.jsp");
        requestDispatcher.forward(request, response);
    }

}
```


result.jsp

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
EL표기법으로 출력합니다.<br>
${v1} + ${v2} = ${result} <br><br>

스클립틀릿과 표현식을 이용해 출력합니다.<br>
<%
    int v1 = (int)request.getAttribute("v1");
    int v2 = (int)request.getAttribute("v2");
    int result = (int)request.getAttribute("result");
%>

<%=v1%> + <%=v2 %> = <%=result %>
</body>
</html>
```



### **생각해보기**

1. 객체지향에서 객체는 관련된 것들을 모아서 가지고 있는 특징이 있습니다. 웹 페이지 URL도 관련된 URL이 있습니다. 예를 들어, 게시판 글쓰기, 읽기, 목록 보기 등은 모두 게시판과 관련된 URL일 것입니다. 하지만 지금까지의 예제들을 보면 서블릿은 하나의 URL만 처리하고 있습니다. 하나의 서블릿이 여러 개의 요청을 받을 수는 없을까요?
   (힌트 : 서블릿 URL mapping에서 와일드카드('*'기호)를 사용하는 방법에 대해서 조사해보세요.)

   /test/* 와 같은 형태로 mapping 하면 /test로 시작하는 모든 요청이 해당 Servlet으로 입력되고 request.getRequestURI() 등을 통해서 실제 입력된 uri를 구분가능.

# 5. scope - BE

## 1) scope란?

### **학습 목표**

1. 4가지 scope에 대해서 이해한다.

### **핵심 개념**

- application scope
- session scope
- request scope
- page scope

### **학습하기**

**Scope 란?**

영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

[![img](https://cphinf.pstatic.net/mooc/20180129_297/1517205425406SvaC6_JPEG/2_5_1_scope_.jpg?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16708/#)

출처 http://inheritingjava.blogspot.kr/2011/04/chapter-42-scope-of-javabeans-in-jsp.html

**4가지 Scope**

- Application : 웹 어플리케이션이 시작되고 종료될 때까지 변수가 유지되는 경우 사용
- Session : 웹 브라우저 별로 변수가 관리되는 경우 사용
- Request : http요청을 WAS가 받아서 웹 브라우저에게 응답할 때까지 변수가 유지되는 경우 사용
- Page : 페이지 내에서 지역변수처럼 사용



### **생각해보기**

1. 회사 관리 프로그램을 만듭니다. 회사 전체적으로 사용되는 특정 정보가 약 1메가 정도 있습니다. 이 정보는 자주 바뀌지 않고, 모든 사원들이 공통적으로 사용하는 코드입니다. 이러한 정보는 어떤 scope로 사용하는 것이 좋을까요?

   Application?

## 2) page scope

### **학습 목표**

1. page scope를 이해한다. 
2. page scope를 사용할 수 있다. 

### **핵심 개념**

- PageContext

### **학습하기**

**Page Scope**

영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

**Page Scope**

- PageContext 추상 클래스를 사용한다.
- JSP 페이지에서 pageContext라는 내장 객체로 사용 가능 하다.
- forward가 될 경우 해당 Page scope에 지정된 변수는 사용할 수 없다.
- 사용방법은 Application scope나 Session scope, request scope와 같다.
- 마치 지역변수처럼 사용된다는 것이 다른 Scope들과 다릅니다.
- jsp에서 pageScope에 값을 저장한 후 해당 값을 EL표기법 등에서 사용할 때 사용됩니다.
- 지역 변수처럼 해당 jsp나 서블릿이 실행되는 동안에만 정보를 유지하고자 할 때 사용됩니다.

### **생각해보기**

1. page scope를 이용하여 사용되는 변수와 지역변수는 거의 유사합니다. 하지만, 앞으로 배울 EL과 JSTL을 이용할 경우에는 구분되어 사용될 경우가 발생합니다. page scope와 지역변수가 유사하다고 하였는데요. 어떤 부분에서 유사할까요?

## 3) request scope

### **학습 목표**

1. request scope를 이해한다.
2. request scope를 사용 할 수 있다. 

### **핵심 개념**

- HttpServletRequest
- forward
- request.setAttribute()
- request.getAttribute()

### **학습하기**

**Request**

영상 우측 하단에 자막 스크립트 ON 설정을 한 후 강의를 시청하시면 학습에 도움이 됩니다.

**Request Scope**

- http 요청을 WAS가 받아서 웹 브라우저에게 응답할 때까지 변수값을 유지하고자 할 경우 사용한다.
- HttpServletRequest 객체를 사용한다.
- JSP에서는 request 내장 변수를 사용한다.
- 서블릿에서는 HttpServletRequest 객체를 사용한다.
- 값을 저장할 때는 request 객체의 setAttribute()메소드를 사용한다.
- 값을 읽어 들일 때는 request 객체의 getAttribute()메소드를 사용한다.
- forward 시 값을 유지하고자 사용한다.
- 앞에서 forward에 대하여 배울 때 forward 하기 전에 request 객체의 setAttribute() 메소드로 값을 설정한 후, 서블릿이나 jsp에게 결과를 전달하여 값을 출력하도록 하였는데 이렇게 포워드 되는 동안 값이 유지되는 것이 Request scope를 이용했다고 합니다.

### **생각해보기**

1. 리다이렉트 될 경우에도 request scope를 이용하면 정보를 유지할 수 있을까요?

   X

2. 만약 정보를 유지할 수 없다면 이유가 무엇일까요?

   redirect될 때는 새로운 request 객체가 생성되기 때문



## 4) session scope

### **학습 목표**

1. session scope를 이해한다.
2. session scope를 사용할 수 있다. 

### **핵심 개념**

- HttpSession
- session.setAttribute()
- session.getAttribute()

### **학습하기**

**Session Scope**

- 웹 브라우저별로 변수를 관리하고자 할 경우 사용한다.
- 웹 브라우저간의 탭 간에는 세션정보가 공유되기 때문에, 각각의 탭에서는 같은 세션정보를 사용할 수 있다.
- HttpSession 인터페이스를 구현한 객체를 사용한다.
- JSP에서는 session 내장 변수를 사용한다.
- 서블릿에서는 HttpServletRequest의 getSession()메소드를 이용하여 session 객체를 얻는다.
- 값을 저장할 때는 session 객체의 setAttribute()메소드를 사용한다.
- 값을 읽어 들일 때는 session 객체의 getAttribute()메소드를 사용한다.
- 장바구니처럼 사용자별로 유지가 되어야 할 정보가 있을 때 사용한다.

### **생각해보기**

1. session scope는 어떤 경우에 이용하는 것이 좋을까요? 예를 한번 생각해보세요.

## 5) application scope

### **학습 목표**

1. application scope를 이해한다.
2. application scope를 사용할 수 있다. 

### **핵심 개념**

- ServletContext
- setAttribute
- getAttribute

### **학습하기**

**Application Scope**

- 웹 어플리케이션이 시작되고 종료될 때까지 변수를 사용할 수 있다.
- **<u>ServletContext</u>** 인터페이스를 구현한 객체를 사용한다.
- jsp에서는 application 내장 객체를 이용한다.
- 서블릿의 경우는 <u>**getServletContext()**</u>메소드를 이용하여 application객체를 이용한다.
- 웹 어플리케이션 하나당 하나의 application객체가 사용된다.
- 값을 저장할 때는 application객체의 setAttribute()메소드를 사용한다.
- 값을 읽어 들일 때는 application객체의 getAttribute()메소드를 사용한다.
- 모든 클라이언트가 공통으로 사용해야 할 값들이 있을 때 사용한다.



### **실습코드**

ApplicationScope01.java

```java
package examples;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ApplicationScope01
 */
@WebServlet("/ApplicationScope01")
public class ApplicationScope01 extends HttpServlet {
    private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public ApplicationScope01() {
        super();
        // TODO Auto-generated constructor stub
    }

    /**
     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/html; charset=UTF-8");
        
        PrintWriter out = response.getWriter();
        
        
        ServletContext application = getServletContext();
        int value = 1;
        application.setAttribute("value", value);
        
        
        out.println("<h1>value : " + value + "</h1>");
        
    }

}
```



ApplicationScope02.java

```java
package examples;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ApplicationScope01
 */
@WebServlet("/ApplicationScope02")
public class ApplicationScope02 extends HttpServlet {
    private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public ApplicationScope02() {
        super();
        // TODO Auto-generated constructor stub
    }

    /**
     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/html; charset=UTF-8");
        
        PrintWriter out = response.getWriter();
        
        ServletContext application = getServletContext();
        
        
        try {
            int value = (int)application.getAttribute("value");
            value++;
            application.setAttribute("value", value);
            out.println("<h1>value : " + value + "</h1>");
        }catch(NullPointerException ex) {
            out.println("value가 설정되지 않습니다.");
        }
        
        
    }

}
```



applicationscope01.jsp

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<%
    try{
        int value = (int)application.getAttribute("value");
        value = value + 2;
        application.setAttribute("value", value);
%>
        <h1><%=value %></h1>
<%        
    }catch(NullPointerException ex){
%>
        <h1>설정된 값이 없습니다.</h1>
<%        
    }
%>

</body>
</html>
```



### **생각해보기**

1. 어플리케이션 스코프에 List객체를 저장했습니다. 이 List객체에 주기적으로 값이 저장은 되지만, 삭제는 되지 않고 있습니다. 이 경우 어떤 문제가 발생할 수 있을까요?

# 6. JSTL & EL - BE

## 1) EL(Expression Language)

### **학습 목표**

1. EL을 이해한다.
2. EL을 사용할 수 있다. 

### **핵심 개념**

- EL
- isELIgnored

### **학습하기**

**표현 언어란?**

- 표현 언어(Expression Language)는 값을 표현하는 데 사용되는 스크립트 언어로서 JSP의 기본 문법을 보완하는 역할을 한다.
  - 표현식(Expression, <%= %>)을 대체 가능
  - JSP의 스크립트 요소에 비해 가독성이 좋다



**표현 언어가 제공하는 기능**

- JSP의 스코프(scope)에 맞는 속성 사용
- 집합 객체(Collection, Framework의 State 등)에 대한 접근 방법 제공
- 수치 연산, 관계 연산, 논리 연산자 제공
- 자바 클래스 메소드 호출 기능 제공
- 표현 언어만의 기본 객체 제공



**표현언어의 표현방법**

[![img](https://cphinf.pstatic.net/mooc/20180130_78/1517281954147RNccz_PNG/2_6_1__.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16714/#)

- **표현언어의 표현 방법**

**표현언어의 기본 객체**

[![img](https://cphinf.pstatic.net/mooc/20180130_153/1517281495386qOuqH_PNG/2_6_1__.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16714/#)

- **표현언어의 표현방법**

**표현 언어의 기본 객체 사용 예**

[![img](https://cphinf.pstatic.net/mooc/20180130_68/1517282068498tAlQM_PNG/2_6_1____.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16714/#)

- **표현언어의 기본객체 사용의 예**
  - JSP가 출력에 주로 사용되므로 EL을 사용하면 복잡한 코드를 단축할 수 있다

**표현 언어의 데이터 타입**

- 불리언 타입 - true와 false
- 정수타입 - 0~9로 이루어진 정수 값 음수의 경우 '-'가 붙음
- 실수타입 - 0~9로 이루어져 있으며, 소수점('.')을 사용할 수 있고, 3.24e3과 같이 지수형으로 표현 가능하다.
- 문자열 타입 - 따옴표( ' 또는" )로 둘러싼 문자열. 만약 작은 따옴표(')를 사용해서 표현할 경우 값에 포함된 작은 따옴표는 \' 와 같이 \ 기호와 함께 사용해야 한다.
- \ 기호 자체는 \\ 로 표시한다.
- 널 타입 - null

 



[![img](https://cphinf.pstatic.net/mooc/20180130_27/1517286832617YwnDB_PNG/2_6_1_.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16714/#)

- **객체 접근 규칙**

**객체 접근 규칙**

- 표현 1이나 표현 2가 null이면 null을 반환한다.
- 표현1이 Map일 경우 표현2를 key로한 값을 반환한다.
- 표현1이 List나 배열이면 표현2가 정수일 경우 해당 정수 번째 index에 해당하는 값을 반환한다.
  - 만약 정수가 아닐 경우에는 오류가 발생한다.
- 표현1이 객체일 경우는 표현2에 해당하는 getter메소드에 해당하는 메소드를 호출한 결과를 반환한다.

 

**표현 언어의 수치 연산자**

- \+ : 덧셈
- \- : 뺄셈
- \* : 곱셈
- / 또는 **<u>div</u>** : 나눗셈
- % 또는 **<u>mod</u>** : 나머지
- 숫자가 아닌 객체와 수치 연산자를 사용할 경우 객체를 숫자 값으로 변환 후 연산자를 수행 : ${"10"+1} → ${10+1}
- 숫자로 변환할 수 없는 객체와 수치 연산자를 함께 사용하면 에러를 발생 : ${"열"+1} → 에러
- 수치 연산자에서 사용되는 객체가 null이면 0으로 처리 : ${null + 1} → ${0+1}

 

**비교 연산자**

- == 또는 eq
- != 또는 ne
- < 또는 lt
- \> 또는 gt
- <= 또는 le
- \>= 또는 ge
- 문자열 비교: ${str == '값'} str.compareTo("값") == 0 과 동일

 

**논리 연산자**

- && 또는 and
- || 또는 or
- ! 또는 not

 

**empty 연산자, 비교선택 연산자**

[![img](https://cphinf.pstatic.net/mooc/20180130_17/1517287228502gEf9g_PNG/2_6_1_empty_%2C__.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16714/#)

- **연산자, 비교선택 연산자**

**연산자 우선순위**

1. [] .
2. ()
3. \- (단일) not ! empty
4. \* / div % mod
5. \+ -
6. < > <= >= lt gt le ge
7. == != eq ne
8. && and
9. || or
10. ? :

 

**표현 언어 비활성화 : JSP에 명시하기**

- <%@ page isELIgnored = "true" %>

[![img](https://cphinf.pstatic.net/mooc/20180130_20/15172876538779gHtO_PNG/2_6_1___.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16714/#)

출처 https://docs.oracle.com/cd/E19316-01/819-3669/bnaic/index.html



### **실습코드**

el01.jsp

Scope별 표현 언어의 사용

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%
    pageContext.setAttribute("p1", "page scope value");
    request.setAttribute("r1", "request scope value");
    session.setAttribute("s1", "session scope value");
    application.setAttribute("a1", "application scope value");
%>    
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
pageContext.getAttribute("p1") : ${pageScope.p1 }<br>
request.getAttribute("r1") : ${requestScope.r1 }<br>
session.getAttribute("s1") : ${sessionScope.s1 }<br>
application.getAttribute("a1") : ${applicationScope.a1 }<br>
<br><br>
pageContext.getAttribute("p1") : ${p1 }<br>
request.getAttribute("r1") : ${r1 }<br>
session.getAttribute("s1") : ${s1 }<br>
application.getAttribute("a1") : ${a1 }<br>

</body>
</html>
```



### **실습코드**

el02.jsp

표현 언어의 연산

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%
    request.setAttribute("k", 10);
    request.setAttribute("m", true);
%>    
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
k : ${k } <br>
k + 5 : ${ k + 5 } <br>
k - 5 : ${ k - 5 } <br>
k * 5 : ${ k * 5 } <br>
k / 5 : ${ k div 5 } <br>


k : ${k }<br>
m : ${m }<br>
k > 5 : ${ k > 5 } <br>
k < 5 : ${ k < 5 } <br>
k <= 10 : ${ k <= 10} <br>
k >= 10 : ${ k >= 10 } <br>
m : ${ m } <br>
!m : ${ !m } <br>

</body>
</html>
```

EL 문법 사용하지 않고 문자열 그대로 표시할 때

```jsp
<%@ page isELIgnored = "true" %> 
```



### **생각해보기**

1. 표현식으로 값을 출력하는 것과 EL을 이용해서 값을 출력하는 것 중 어떤 게 편해 보이나요? 혹시 표현식으로 표현하는 것이 좀 더 편리해 보인다 하더라도 실망하지 마세요. EL은 다음 시간에 배우게 될 JSTL과 함께 사용하면 더 효율적으로 사용할 수 있습니다.



## 2) JSTL(JSP Standard Tag Library)

### **학습 목표**

1. JSTL을 이해한다.
2. JSTL을 사용할 수 있다. 

### **핵심 개념**

- JSTL
- core tag

### **학습하기**

**JSTL이란?**

- JSTL(JSP Standard Tag Library)은 JSP 페이지에서 조건문 처리, 반복문 처리 등을 html tag형태로 작성할 수 있게 도와줍니다.
  - 출력만 하는 JSP에서 java 코드를 굳이 안써도 된다

[![img](https://cphinf.pstatic.net/mooc/20180130_149/1517289583487Ac0YJ_PNG/2_6_2_jstl.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16713/#)

- **jstl이란**

**JSTL을 사용하려면?**

- http://tomcat.apache.org/download-taglibs.cgi
- 위의 사이트에서 3가지 jar파일을 다운로드 한 후 WEB-INF/lib/ 폴더에 복사를 한다.

[![img](https://cphinf.pstatic.net/mooc/20180130_248/1517289861733CmzUv_PNG/2_6_2_jstl_.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16713/#)

- **jstl을 사용하려면**

**JSTL이 제공하는 태그의 종류**

[![img](https://cphinf.pstatic.net/mooc/20180130_273/1517290494334HrB7S_PNG/2_6_2_jstl___.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16713/#)

- **jstl이 제공하는 태그의 종류**

**코어 태그**

[![img](https://cphinf.pstatic.net/mooc/20180130_226/1517290578353rKRbE_PNG/2_6_2_jstl_.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16713/#)

- **jstl 코어태그**

**코어 태그: 변수 지원 태그 - set, remove**



[![img](https://cphinf.pstatic.net/mooc/20180226_240/1519633482313pWfP8_PNG/1.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16713/#)

- **변수 지원 태그**

### **실습코드**

jstl01.jsp

set, remove의 활용

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> 
<c:set var="value1" scope="request" value="kang"/>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>

성 : ${value1} <br>

<c:remove var="value1" scope="request"/>

성 : ${value1 }
</body>
</html>
```

### **코어태그: 변수 지원 태그 - 프로퍼티, 맵의 처리**

[![img](https://cphinf.pstatic.net/mooc/20180226_103/1519633640114VKW2d_PNG/2.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16713/#)

- **변수 지원 태그**

**코어 태그: 흐름제어 태그**

[![img](https://cphinf.pstatic.net/mooc/20180226_83/1519633710402BlJ2W_PNG/3.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16713/#)

- **흐름제어태그 if**

### **실습코드**

jstl02.jsp

if의 활용

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> 
<%
request.setAttribute("n", 10);
%>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<c:if test="${n == 0}">
n은 과 0과 같습니다.
</c:if>

<c:if test="${n == 10}">
n은 과 10과 같습니다.
</c:if>
</body>
</html>
```



**코어 태그: 흐름제어 태그 - choose**

[![img](https://cphinf.pstatic.net/mooc/20180130_4/1517292532220uxSVD_PNG/2_6_2__choose.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16713/#)

- **흐름제어태그 choose**

### **실습코드**

jstl03.jsp

switch의 활용

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> 
<%@ page import="java.util.*" %>
<%
    request.setAttribute("score", 83);
%>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<c:choose>
    <c:when test="${score >=90 }">
    A학점입니다.
    </c:when>
    <c:when test="${score >=80 }">
    B학점입니다.
    </c:when>
    <c:when test="${score >=70 }">
    C학점입니다.
    </c:when>
    <c:when test="${score >=60 }">
    D학점입니다.
    </c:when>
    <c:otherwise>
    F학점입니다.
    </c:otherwise>            
</c:choose>
</body>
</html>
```



**코어 태그: 흐름제어 태그 - forEach**

[![img](https://cphinf.pstatic.net/mooc/20180130_218/1517292735244tmWgM_PNG/2_6_2__forEach.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16713/#)

- **흐름제어태그 forEach**

### **실습코드**

jstl04.jsp

forEach의 활용

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> 
<%@ page import="java.util.*" %>
<%
    List<String> list = new ArrayList<>();
    list.add("hello");
    list.add("world");
    list.add("!!!");
    request.setAttribute("list", list);
%>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<c:forEach items="${list}" var="item">
${item } <br>
</c:forEach>
</body>
</html>
```



**코어 태그: 흐름제어태그 - import**

[![img](https://cphinf.pstatic.net/mooc/20180130_93/1517293018908uGgzT_PNG/2_6_2__import.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16713/#)

- **흐름제어태그 import**

### **실습코드**

jstlValue.jsp

import의 활용

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
Kang kyungmi
```

jstl05.jsp

import의 활용

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> 
<%@ page import="java.util.*" %>
<c:import url="http://localhost:8080/webapp/jstlValue.jsp" var="urlValue" scope="request"></c:import>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
읽어들인 값 : ${urlValue}
</body>
</html>
```

**코어 태그: 흐름제어태그 - redirect**

[![img](https://cphinf.pstatic.net/mooc/20180130_170/1517293246119dFJ4F_PNG/2_6_2__redirect.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16713/#)

- **흐름제어태그 redirect**

### **실습코드**

jtl06.jsp

redirect의 활용

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> 
<c:redirect url="jstlRedirectPage.jsp"></c:redirect>
```



jstlRedirectPage.jsp

redirect의 활용

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<h1> redirect된 화면입니다.</h1>
</body>
</html>
```



**코어 태그: 기타태그 - out**

[![img](https://cphinf.pstatic.net/mooc/20180130_55/1517293404340WP4J3_PNG/2_6_2__out.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16713/#)

- **흐름제어태그 choose**

**코드실습**

jstl07.jsp

out의 활용

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions"%> 
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<c:set var="t" value="<script type='text/javascript'>alert(1);</script>" />
${t}
<c:out value="${t}" escapeXml="true" />
<c:out value="${t}" escapeXml="false" />
</body>
</html>
```

- 특수기호 `< > & ' "`로 인해 tag로 해석되는 것을 방지하고 일반 텍스트로 출력하는 역할을 한다
- 그냥 print 나 cout 같은걸로 이해하면 될 듯?



### **생각해보기**

1. JSTL의 태그는 XML태그 문법을 사용합니다. 그래서 반드시 태그가 닫히거나 '/>'로 끝나야 합니다. JSP가 제공하는 문법 중 사용자 정의 태그라는 것을 통해 만들어졌기 때문입니다. 이번 시간엔 JSTL의 core태그에 대해서 살펴봤는데요. 그 외의 태그들에는 어떤 게 있는지 찾아보고, 왜 그러한 태그가 필요한지 생각해보세요.



# 7. MySQL - BE

## 1) intro

### **학습 목표**

1. 데이터베이스와 데이터베이스 메니지먼트 시스템에 대해서 이해하고, 설명할 수 있다.

### **핵심 개념**

- 데이터베이스 (Database)
- 데이터베이스 메니지먼트 시스템 (DBMS)

### **학습하기**

**데이터베이스와 데이터베이스 관리 시스템**

- Q> 데이터베이스와 데이터베이스 관리 시스템을 어린이도 알 수 있을 정도로 설명해주세요.
- A> 어린이가 가지고 있는 책(정보)들을 데이터베이스라고 한다면, 그 책을 관리해주는 엄마는 데이터베이스 관리 시스템이라고 말할 수 있습니다.



**데이터베이스의 기본개념 (정의)**

- 데이터의 집합 (a Set of Data)
- 여러 응용 시스템(프로그램)들의 통합된 정보들을 저장하여 운영할 수 있는 공용(share) 데이터의 집합
- 효율적으로 저장, 검색, 갱신할 수 있도록 데이터 집합들끼리 연관시키고 조직화되어야 한다.



**데이터베이스의 특성**

- 실시간 접근성(Real-time Accessability)
  \- 사용자의 요구를 즉시 처리할 수 있다.

- 계속적인 변화(Continuous Evolution)
  \- 정확한 값을 유지하려고 삽입·삭제·수정 작업 등을 이용해 데이터를 지속적으로 갱신할 수 있다.

- 동시 공유성(Concurrent Sharing)
  \- 사용자마다 서로 다른 목적으로 사용하므로 동시에 여러 사람이 동일한 데이터에 접근하고 이용할 수 있다.

- 내용 참조(Content Reference)
  \- 저장한 데이터 레코드의 위치나 주소가 아닌 사용자가 요구하는 데이터의 내용, 즉 데이터 값에 따라 참조할 수 있어야 한다.



**데이터베이스 관리 시스템 (Database Management System = DBMS)**

- 데이터베이스를 관리하는 소프트웨어
- 여러 응용 소프트웨어(프로그램) 또는 시스템이 동시에 데이터베이스에 접근하여 사용할 수 있게 한다
- 필수 3기능
  \- 정의기능 :  데이터 베이스의 논리적, 물리적 구조를 정의
  \- 조작기능 : 데이터를 검색, 삭제, 갱신, 삽입, 삭제하는 기능
  \- 제어기능 :  데이터베이스의 내용 정확성과 안전성을 유지하도록 제어하는 기능
- Oracle, SQL Server, MySQL, DB2 등의 상용 또는 공개 DBMS가 있다.

  

**데이터베이스 관리 시스템의 장/단점**

- 장점
  \- 데이터 중복이 최소화
  \- 데이터의 일관성 및 무결성 유지
  \- 데이터 보안 보장
- 단점
  \- 운영비가 비싸다
  \- 백업 및 복구에 대한 관리가 복잡
  \- 부분적 데이터베이스 손실이 전체 시스템을 정지

### **생각해보기**

1. Database와 DBMS를 개발자가 아닌 사람에게 설명해보세요.

   데이터베이스는 살제 데이터를 담아놓은 공간이고, DBMS는 데이터베이스의 데이터들에게 접근하기 위해서 존재하는, 그 데이터들을 찾기쉽게 검색/ 수정하기 쉽게 수정/ 삭제하기 쉽게 삭제/하는 기능들을 하는 공간

## 2) MySQL 다운로드 및 설치

### **학습 목표**

1. MySQL DBMS를 다운로드하고 설치할 수 있다.

### **핵심 개념**

- MySQL

### **학습하기**

**MySQL설치**

Windows와 Mac에서 MySQL을 설치하는 방법에 대해 알아보도록 하겠습니다.

 

**1. Windows 에서 MySQL 설치하기**

**MySQL 설치 프로그램 다운로드 하기**

https://www.mysql.com/downloads/

위의 URL주소로 접속합니다.

[![img](https://cphinf.pstatic.net/mooc/20180130_220/1517301639758tipul_PNG/2_7_2_01.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

접속하면 하단에 위와 같은 링크가 보여집니다. Community(GPL) Downloads를 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180130_50/15173016771322yd4l_PNG/2_7_2_02.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

다시 화면이 바뀌고, 하단에서 위와 같은 부분을 찾습니다. MySQL Community Server Download링크를 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180130_141/1517301716304Elg4m_PNG/2_7_2_03.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

본인이 사용하는 윈도우에 맞는 버전을 선택합니다. 그리고 나서 Go to Download Page버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180130_178/1517301741527LIfS9_PNG/2_7_2_04.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

위와 같은 화면으로 전환되면 붉은 사각형으로 처져 있는 Download버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180130_26/1517301764096QbT2o_PNG/2_7_2_05.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

로그인을 하지 않고 다운로드 하려면 No thanks, just start my download 링크를 클릭합니다. MySQL Community Edition이 이제 다운로드 됩니다. mysql-installer-community-5.7.21.0.msi 를 실행합니다.

[![img](https://cphinf.pstatic.net/mooc/20180130_66/1517301795664jFdjh_PNG/2_7_2_06.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

설치 프로그램을 실행하면 가장 먼저 라이선스에 대해서 물어보는 화면이 보입니다. 라이선스 동의 체크박스를 선택한 후 Next버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180130_230/1517301822203xcY00_PNG/2_7_2_07.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

Developer Default를 선택한 후 Next버튼을 클릭합니다. 말 그대로 개발자를 위한 MySQL을 설치하겠다는 것입니다. 개발자를 위한 다양한 도구들이 함께 설치가 됩니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_207/1517373007940UfqlB_PNG/2_7_2_07-1.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

위와 같은 화면이 보이면, Execute버튼을 클릭하여 설치를 진행합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_270/1517373039324B9lDb_PNG/2_7_2_08.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

MySQL이 설치되고 실행되기 위해서 필요한 도구들에 대해서 Execute를 눌러 설치한 후 Next버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_177/15173730685845io2c_PNG/2_7_2_09.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

설치할 항목이 표시됩니다. Execute버튼을 클릭하여 설치를 시작합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_97/1517373135155jRYVo_PNG/2_7_2_10.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

설치가 모두 진행되었다면 Next버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_196/1517373151599Lltmo_PNG/2_7_2_11.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

MySQL과 관련된 설정 과정이 진행된다는 안내가 표시됩니다. Next버튼을 클릭합니다. root계정의 암호를 설정하는 부분까지 기본값으로 설치를 진행합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_300/1517373194725igKRc_PNG/2_7_2_12.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

MySQL의 관리자(root)계정의 암호를 설정합니다. 암호를 잊지 않게 조심해 주세요. 암호를 입력했다면 Next버튼을 클릭합니다. 커넥션 연결 테스트를 진행할 때까지 기본값으로 설치를 진행하도록 하겠습니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_60/15173732195796I7yM_PNG/2_7_2_13.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

MySQL이 잘 실행되고 있는지 확인하기 위한 화면입니다. 앞에서 입력했던 root사용자의 암호를 입력하고 Check버튼을 클릭합니다. 위와 같이 연결 성공이라는 녹색화면이 보이면 Next버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_18/1517373256380a1AEr_PNG/2_7_2_14.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

모든 설치 과정이 끝났습니다. Finish버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_221/1517373280390svBSo_PNG/2_7_2_15.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

모든 인스톨 과정이 완료되었습니다. Finish버튼을 클릭하면 MySQL Workbench와 MySQL Shell이 실행될 것이라는 체크박스가 선택되어 있습니다. Finish버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_225/1517373299598m4PwL_PNG/2_7_2_16.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

MySQL Workbench 실행화면입니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_268/1517373321570TWSkE_PNG/2_7_2_17.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

MySQL Shell 쉘의 실행화면입니다. 앞으로 MySQL을 이용해서 개발을 진행할 때 워크벤치나 MySQL 쉘을 이용해야하는 경우가 많이 발생할 것입니다. 창을 닫고, 프로그램을 종료해주세요.

[![img](https://cphinf.pstatic.net/mooc/20180131_203/1517373400661QD25h_PNG/2_7_2_18.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

윈도우 메뉴를 보면 MySQL그룹이 새로 생긴 것을 볼 수 있습니다. 위의 그림중에서 붉은 상자로 되어 있는 부분이 워크벤치와 MySQL shell을 실행하기 위한 아이콘입니다. 뒤에서 MySQL을 사용할 때 위의 아이콘을 선택하시면 됩니다. 콘솔창에서 mysql 명령을 실행하려면, 다음의 경로를 PATH에 지정하세요. 윈도우 검색창에 "환경" 이라고 입력합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_33/1517373431461Yc8M2_PNG/2_7_2_19.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

시스템 환경 변수 편집이라는 프로그램이 보이면 클릭해서 실행합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_177/15173734556398WYJk_PNG/2_7_2_20.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

위와 같은 시스템 속성창이 열리면 아래 쪽의 "환경 변수"버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_38/15173734789828xbN0_PNG/2_7_2_21.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

시스템 변수 중에서 Path를 선택하고, "편집" 버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_276/1517373550179G8GOy_PNG/2_7_2_22.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16717/#)

"새로 만들기"버튼을 클릭한 후, 아래의 path를 입력한 후 "확인" 버튼을 클릭합니다. 이전 창도 모두 "확인"버튼을 눌러 닫습니다.  C:\Program Files\MySQL\MySQL Server 5.7\bin  이제 콘솔창에서 mysql 명령을 수행할 수 있습니다.

### **생각해보기**

MySQL DBMS를 잘 설치하셨나요?

DBMS는 여러 명의 사용자가 동시에 접속해서 사용할 수 있다고 앞에서 배웠었습니다.

그런데, 개인용 PC에 설치된 MySQL은 항상 켜져 있는 것이 아닐 테니, 여러 사람이 동시에 이용하기 어려울 것입니다.

여러 사람이 동시에 항상 접속해서 사용할 수 있으려면 MySQL을 어떤 컴퓨터에 설치하고 운영해야 할까요?



## 3) MySQL 실행

### **학습 목표**

1. MySQL서버를 실행할 수 있다.
2. MySQL서버를 서비스 혹은 데몬 형태로 실행할 수 있다.

### **핵심 개념**

- Service
- 데몬 (Daemon)

### **학습하기**

**MySQL 서버 실행 방법**

이번 시간엔 MySQL서버를 실행하는 방법에 대해 알아보도록 하겠습니다.

 

**1. MS Window 10**

[![img](https://cphinf.pstatic.net/mooc/20180130_198/1517302699674rSr1n_PNG/2_7_3_01.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16718/#)

윈도우 검색 버튼에서 서비스라고 입력하면 서비스(데스크톱 앱)이라는 프로그램이 보입니다. 해당 프로그램을 선택하세요.

[![img](https://cphinf.pstatic.net/mooc/20180130_261/1517302737890hlf8L_PNG/2_7_3_02.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16718/#)

위와 같이 MySQL57 이라는 이름으로 서비스가 실행된 것을 알 수 있습니다. 참고로 MySQL이 설치될 때 유심히 봤다면 MySQL57이라는 서비스 이름으로 서비스가 실행된다는 메시지가 보입니다. 시작 유형은 자동으로 되어 있기 때문에, 윈도우가 실행될 때 자동으로 서버가 서비스 형태로 실행됩니다. 나중에, MySQL이 동작하지 않는다면 해당 서비스에서 “실행 중”이라고 표시되는지 확인해주세요.

### **생각해보기**

MySQL 프로세스가 운영체제에 실행되고 있는지 확인하려면 어떻게 해야 할까요?

자신이 사용하는 운영체제에 맞게 고민해보세요.

## 4) MySQL 종료

### **학습 목표**

1. MySQL서버를 종료할 수 있습니다.

### **핵심 개념**

- service
- 데몬(Daemon)

### **학습하기**

**MySQL 종료**

이번 시간에는 MySQL서버를 종료하는 방법에 대해서 알아보도록 하겠습니다.

 

**1. 윈도우에서 MySQL서버 종료하기**

윈도우에서 MySQL서버를 종료하는 것은 간단합니다.

[![img](https://cphinf.pstatic.net/mooc/20180130_182/1517303636725QeBB1_PNG/2_7_4_01.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16719/#)

서비스 목록에서 MySQL57을 선택한 후 우측버튼을 클릭합니다. 우측버튼을 클릭했다면 속성버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180130_171/1517303656745hkA85_PNG/2_7_4_02.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16719/#)

속성 창에서 “중지”버튼을 클릭하면 MySQL서버는 정지됩니다. 만약, 윈도우가 실행될 때 자동으로 실행되길 원하지 않는다면, 시작 유형 “자동”을 “수동”으로 변경한 후 “확인”버튼을 클릭하면 됩니다. 이 경우에는 위의 유형 창에서 “시작”버튼을 매번 눌러줘야 MySQL서버가 실행됩니다.

# 8. SQL - BE

## 1) SQL이란?

### **학습 목표**

1. SQL이 무엇인지 이해한다.
2. MySQL에서 Database를 생성할 수 있다.
3. MySQL에서 Database를 이용하는 계정을 생성하고, 권한을 부여할 수 있다.
4. 생성한 Database에 sample데이터를 추가할 수 있다.

### **핵심 개념**

- create database
- grant
- flush privileges
- select

### 학습하기

**SQL(Structured Query Language)**

- SQL은 데이터를 보다 쉽게 검색하고 추가, 삭제, 수정 같은 조작을 할 수 있도록 고안된 컴퓨터 언어입니다.
- 관계형 데이터베이스에서 데이터를 조작하고 쿼리하는 표준 수단입니다.
- DML (Data Manipulation Language): 데이터를 조작하기 위해 사용합니다.
  INSERT, UPDATE, DELETE, SELECT 등이 여기에 해당합니다.
- DDL (Data Definition Language): 데이터베이스의 스키마를 정의하거나 조작하기 위해 사용합니다.
  CREATE, DROP, ALTER 등이 여기에 해당합니다.
- DCL (Data Control Language) : 데이터를 제어하는 언어입니다.
  권한을 관리하고, 테이터의 보안, 무결성 등을 정의합니다.
  GRANT, REVOKE 등이 여기에 해당합니다.

 

**Database 생성하기**

콘솔에서 다음과 같이 명령을 실행합니다.

MySQL 관리자 계정인 root로 데이터베이스 관리 시스템에 접속하겠다는 것입니다.

```markup
mysql –uroot  -p
```

window 사용자는 설치 시에 입력했던 암호를 입력합니다.

맥 사용자는 암호가 없으니 그냥 엔터를 입력하면 됩니다.

MySQL DBMS에 접속하면 “mysql>” 프롬프트가 보입니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_298/1517364008365xNdNE_PNG/2_8_1_Database.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16720/#)

- **Database 생성하기**

관리자 계정으로 MySQL에 접속했다면, 다음과 같은 명령으로 데이터베이스를 생성합니다.

```markup
 mysql> create database DB이름;
```

우리는 다음과 같은 명령을 실행하여 DB이름을 “connectdb＂로 생성하도록 하겠습니다.

```markup
mysql> create database connectdb;
```

[![img](https://cphinf.pstatic.net/mooc/20180131_86/1517363514600jvDDb_PNG/2_8_1_Database2.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16720/#)

- **Database 생성하기2**

**Database 사용자 생성과 권한 주기**

- Database를 생성했다면, 해당 데이터베이스를 사용하는 계정을 생성해야 합니다.
- 또한, 해당 계정이 데이터베이스를 이용할 수 있는 권한을 줘야 합니다.
- 아래와 같은 명령을 이용해서 사용자 생성과 권한을 줄 수 있습니다.
- db이름 뒤의 * 는 모든 권한을 의미한다.
- @’%’는 어떤 클라이언트에서든 접근 가능하다는 의미이고, @’localhost’는 해당 컴퓨터에서만 접근 가능하다는 의미입니다.
- flush privileges는 DBMS에게 적용을 하라는 의미입니다.
- 해당 명령을 반드시 실행해줘야 합니다.

```markup
grant all privileges on db이름.* to 계정이름@'%' identified by ＇암호’;
grant all privileges on db이름.* to 계정이름@'localhost' identified by ＇암호’;
flush privileges;
```

- 사용자 계정이름은 'connectuser', 암호는 'connect123!@#', 해당 사용자가 사용하는 데이터베이스는 'connectdb'로 계정을 생성하려면 다음과 같이 명령을 수행합니다.

```markup
grant all privileges on connectdb.* to connectuser@'%' identified by 'connect123!@#';

grant all privileges on connectdb.* to connectuser@'localhost' identified by 'connect123!@#';

flush privileges;
```

[![img](https://cphinf.pstatic.net/mooc/20180131_122/1517363659753uRWf0_PNG/2_8_1_Database__%2C_.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16720/#)

- **실행한 모습**

**생성한 Database에 접속하기**

아래와 같이 명령을 실행하여 원하는 데이터베이스에 접속할 수 있습니다.

```markup
mysql –h호스트명 –uDB계정명 –p 데이터베이스이름
```

db이름이 connectdb, db계정이 connectuser, 암호가 connect123!@# 일 경우 콘솔창에서 다음과 같이 입력합니다.

```markup
mysql –h127.0.0.1 –uconnectuser –p connectdb [enter]
```

[![img](https://cphinf.pstatic.net/mooc/20180131_231/1517363293339FNyg8_PNG/2_8_1_Database_.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16720/#)

- **다음과 같이 프롬프트가 보이면 성공**

**MySQL 연결끊기**

프롬프트에서 quit혹은 exit라고 입력합니다.

```markup
mysql> QUIT
mysql> exit
```

[![img](https://cphinf.pstatic.net/mooc/20180131_246/15173642579241u1LW_PNG/2_8_1_Mysql.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16720/#)

- **다음과 같이 Bye라고 나오면 연결 끊기 성공**

**MySQL 버전과 현재 날짜 구하기**

```markup
mysql> SELECT VERSION(), CURRENT_DATE;
+-----------+--------------+
| VERSION() | CURRENT_DATE |
+-----------+--------------+
| 5.1.67    | 2013-01-05   |
+-----------+--------------+
1 row in set (0.00 sec)
```

프롬프트에서는 SQL을 입력합니다.

SQL은 semicolon (;)으로 끝납니다.

SQL은 쿼리(Query)라고 읽습니다.

쿼리는 DBMS에게 명령을 내릴 때 사용하는 문장이라고 생각하면 쉽습니다.

SELECT는 어떤 내용을 조회할 때 사용하는 키워드입니다.

MySQL은 쿼리에 해당하는 결과의 전체 row를 출력하고 마지막에 전체 row 수와 쿼리실행에 걸린 시간을 표시합니다.

 

**키워드는 대소문자를 구별하지 않는다.**

다음 쿼리들은 모두 같습니다.

```markup
mysql> SELECT VERSION(), CURRENT_DATE;
mysql> select version(), current_date;
mysql> SeLeCt vErSiOn(), current_DATE;
```

 

**쿼리를 이용해서 계산식의 결과도 구할 수 있다.**

 함수 및 수식 사용 예제

```markup
mysql> SELECT SIN(PI()/4), (4+1)*5;
+-------------+---------+
| SIN(PI()/4) | (4+1)*5 |
+-------------+---------+
|    0.707107 |      25 |
+-------------+---------+
```

 

**여러 문장을 한 줄에 연속으로 붙여서 실행가능하다.**

각 문장에 semicolon(;)만 붙혀 주면 됩니다.

```markup
mysql> SELECT VERSION(); SELECT NOW();
+--------------+
| VERSION()    |
+--------------+
| 3.22.20a-log |
+--------------+
+---------------------+
| NOW()               |
+---------------------+
| 2004 00:15:33 |
+---------------------+
```

**
**

**하나의 SQL은 여러 줄로 입력가능하다.**

MySQL은 문장의 끝을 라인으로 구분하는 것이 아니라 semicolon(;)으로 구분하기 때문에 여러 줄에 거쳐 문장을 쓰는 것도 가능합니다.

```markup
mysql> SELECT
    -> USER()
    -> ,
    -> CURRENT_DATE;
+--------------------+--------------+
| USER()             | CURRENT_DATE |
+--------------------+--------------+
| joesmith@localhost | 1999-03-18   |
+--------------------+--------------+
```

 

**SQL을 입력하는 도중에 취소할 수 있다.**

긴 쿼리를 작성하다가 중간에 취소해야 하는 경우에는 즉시 \c를 붙혀주면 됩니다.

```markup
mysql> SELECT

    -> USER()

    -> \c

mysql>
```

 

**DBMS에 존재하는 데이터베이스 확인하기**

작업하기 위한 데이터베이스를 선택하기 위해서는 어떤 데이터베이스가 존재하는지 알아보아야 합니다.

현재 서버에 존재하는 데이터베이스를 찾아보기 위해서 SHOW statement을 사용합니다.

```markup
mysql> show databases;
+-----------------------+
| Database               |
+-----------------------+
| information_schema |
| connectdb              |
+-----------------------+
2 rows in set (0.00 sec)
```

 

 

**사용중인 데이터베이스 전환하기**

Database을 선택하기 위해, “use” command 사용합니다.

```markup
mysql> use mydb;
```

데이터베이스를 전환하려면, 이미 데이터베이스가 존재해야 하며 현재 접속 중인 계정이 해당 데이터베이스를 사용할 수 있는 권한이 있어야 합니다.



**데이터를 저장하는 공간 테이블(Table)**

- 마이크로소프트의 엑셀(Excel)을 실행하면 표가 나옵니다. 이러한 표에 각종 값을 저장할 수 있습니다.
- 데이터베이스도 엑셀의 표와 유사한 테이블을 가질 수 있습니다.
- 엑셀과 다른 점은 데이터베이스를 생성해도 테이블은 존재하지 않는다는 것입니다.
- 테이블을 사용하려면 테이블을 생성하는 SQL을 사용해야 합니다.
- 그리고, 테이블에 값을 저장하려면 저장하기 위한 SQL을 사용해야 합니다.



**테이블(table)의 구성요소**

[![img](https://cphinf.pstatic.net/mooc/20180131_276/1517366013781n0BtX_PNG/2_8_1_%28table%29_.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16720/#)

- **테이블(table)의 구성요소**

- 테이블 : RDBMS의 기본적 저장구조 한 개 이상의 column과 0개 이상의 row로 구성합니다.
- 열(Column) : 테이블 상에서의 단일 종류의 데이터를 나타냄. 특정 데이터 타입 및 크기를 가지고 있습니다.
- 행(Row) : Column들의 값의 조합. 레코드라고 불림. 기본키(PK)에 의해 구분. 기본키는 중복을 허용하지 않으며 없어서는 안 됩니다.
- Field : Row와 Column의 교차점으로 Field는 데이터를 포함할 수 있고 없을 때는 NULL 값을 가지고 있습니다.

​           

**현재 데이터베이스에 존재하는 테이블 목록 확인하기**

Database를 선택 후, Database의 전체 테이블 목록을 출력합니다.

```markup
mysql> show tables;

Empty set (0.02 sec)
```

“empty set” 은  데이터베이스에 어떤 테이블도 아직 생성되지 않았다는 것을 알려줍니다.



**SQL 연습을 위한 테이블 생성과 값의 저장**

examples.sql을 다운로드 합니다. [링크 바로가기](https://github.com/connect-boostcamp/boostcourse_fullstack_web/tree/master/part2)





터미널에서 examples.sql이 있는 폴더로 이동한 후, 다음과 같이 명령을 수행합니다.

명령을 수행한 후 암호를 입력합니다.

```markup
mysql   -uconnectuser  -p  connectdb   <  examples.sql
```

examples.sql에는 연습을 위한 테이블 생성문과 해당 테이블에 값을 저장하는 입력문이 존재합니다.

```markup
mysql –uconnectuser -p  connectdb
```

위의 명령으로 connectdb에 접속한 후 다음과 같이 명령을 수행합니다.

```markup
mysql> show tables
```

위의 명령은 접속한 db의 테이블 목록을 보는 명령입니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_157/1517366408574LmBpS_PNG/2_8_1_SQL_____.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16720/#)

- **SQL연습을 위한 테이블 생성과 값의 저장**

**테이블 구조를 확인하기 위한 DESCRIBE 명령**

table 구조를 확인하기 위해, DESCRIBE 명령을 사용할 수 있습니다.

짧게 DESC라고 사용해도 됩니다.

EMPLOYEE테이블의 구조를 확인해 봅시다.

```markup
mysql> desc EMPLOYEE;
```

[![img](https://cphinf.pstatic.net/mooc/20180131_20/15173664556106tJaW_PNG/2_8_1_____DESCRIBE_.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16720/#)



### **생각해보기**

하나의 DBMS에는 여러 개의 데이터베이스를 생성하고, 각각의 데이터베이스를 사용할 수 있는 사용자를 추가할 수 있습니다.

이번 시간에 만든 connectdb와 connectuser 말고, 추가로 데이터베이스를 생성하고, 생성한 데이터베이스를 사용한 사용자를 추가하고 로그인해보세요.



## 2) DML(Select, Insert, Update, Delete)

일단 SKIP

## 3) DDL(Create, Drop)

일단 SKIP

# 9. Maven - BE

## 1) Maven 이란?

### **학습 목표**

1. Maven의 역할에 대해 이해한다.

### **핵심 개념**

- Maven
  Maven은 지금까지 애플리케이션을 개발하기 위해 반복적으로 진행해왔던 작업들을 지원하기 위하여 등장한 도구입니다. 

  Maven을 사용하면 빌드(Build), 패키징, 문서화, 테스트와 테스트 리포팅, git, 의존성관리, svn등과 같은 형상관리서버와 연동(SCMs), 배포 등의 작업을 손쉽게 할 수 있습니다.

- CoC (Convention over Configuration)
  CoC란 일종의 관습을 말하는데, 예를 들자면 프로그램의 소스파일은 어떤 위치에 있어야 하고, 소스가 컴파일된 파일들은 어떤 위치에 있어야 하고 등을 미리 정해놨다는 것입니다.

- pom.xml

### **학습하기**

**Maven이란?**

Maven은 지금까지 애플리케이션을 개발하기 위해 반복적으로 진행해왔던 작업들을 지원하기 위하여 등장한 도구입니다. 

Maven을 사용하면 빌드(Build), 패키징, 문서화, 테스트와 테스트 리포팅, git, 의존성관리, svn등과 같은 형상관리서버와 연동(SCMs), 배포 등의 작업을 손쉽게 할 수 있습니다.

Maven을 이해하려면 CoC(Convention over Configuration)라는 단어를 먼저 이해해야 합니다.

CoC란 일종의 관습을 말하는데, 예를 들자면 프로그램의 소스파일은 어떤 위치에 있어야 하고, 소스가 컴파일된 파일들은 어떤 위치에 있어야 하고 등을 미리 정해놨다는 것입니다.

이 말은 관습에 이미 익숙한 사용자는 쉽게 Maven을 사용할 수 있는데, 관습에 익숙하지 않은 사용자는 이러한 제약사항에 대해서 심한 거부감을 느낄 수 있습니다.

Maven을 사용한다는 것은 어쩌면 이러한 관습 즉 CoC에 대해서 알아나가는 것이라고도 말할 수 있습니다. 



**Maven을 사용할 경우 얻게 되는 이점은?**

Maven을 사용할 경우, 굉장히 편리한 점들이 많습니다.

많은 사람이 손꼽는 장점 중에는 편리한 의존성 라이브러리 관리가 있습니다.

앞에서 JSTL을 학습할 때, 몇 가지 파일을 다운로드 하여 /WEB-INF/lib폴더에 복사하여 사용했었습니다.

관련된 라이브러리가 많아질수록 이러한 방식은 상당히 불편해집니다.

Maven을 사용하면 설정 파일에 몇 줄 적어줌으로써 직접 다운로드 받거나 하는 것을 하지 않아도 라이브러리를 사용할 수 있습니다.

프로젝트에 참여하는 개발자가 많아지게 되면, 프로젝트를 빌드하는 방법에 대하여 가이드하는 것도 쉬운 일이 아닙니다.

Maven을 사용하게 되면 Maven에 설정한 대로 모든 개발자가 일관된 방식으로 빌드를 수행할 수 있게 됩니다.

Maven은 또한 다양한 플러그인을 제공해줘서, 굉장히 많은 일들을 자동화시킬 수 있습니다.

 

**Maven 기본**

Archetype을 이용하여 Maven 기반 프로젝트를 생성할 경우 생성된 프로젝트 하위에 pom.xml 파일이 생성됩니다.

pom.xml 파일을 살펴보면 다음과 같습니다. 

```markup
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>kr.or.connect</groupId>
    <artifactId>examples</artifactId>
    <packaging>jar</packaging>
    <version>1.0-SNAPSHOT</version>
    <name>mysample</name>
    <url>http://maven.apache.org</url>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

각각의 태그의 의미는 다음과 같습니다.

- **project** : pom.xml 파일의 최상위 루트 엘리먼트(Root Element)입니다.
- **modelVersion** : POM model의 버전입니다. 
- **groupId** : 프로젝트를 생성하는 조직의 고유 아이디를 결정합니다. 일반적으로 도메인 이름을 거꾸로 적습니다.
- **artifactId** : 해당 프로젝트에 의하여 생성되는 artifact의 고유 아이디를 결정합니다. Maven을 이용하여 pom.xml을 빌드할 경우 다음과 같은 규칙으로 artifact가 생성됩니다. artifactid-version.packaging. 위 예의 경우 빌드할 경우 examples-1.0-SNAPSHOT.jar 파일이 생성됩니다.
- **packaging** : 해당 프로젝트를 어떤 형태로 packaging 할 것인지 결정합니다. jar, war, ear 등이 해당됩니다.
- **version** : 프로젝트의 현재 버전. 추후 살펴보겠지만 프로젝트가 개발 중일 때는 SNAPSHOT을 접미사로 사용합니다. Maven의 버전 관리 기능은 라이브러리 관리를 편하게 합니다.
- **name** : 프로젝트의 이름입니다.
- **url** : 프로젝트 사이트가 있다면 사이트 URL을 등록하는 것이 가능합니다.

Maven 을 이용할 경우 얻게 되는 큰 이점 중의 하나는 Dependency Management 기능입니다.

위 pom.xml 파일에서 <dependencies/> 엘리먼트가 Dependency Management 기능의 핵심이라고 할 수 있습니다.

해당 엘리먼트 안에 필요한 라이브러리를 지정하게 됩니다.



### **생각해보기**

Maven은 정해진 관습을 사용하기 때문에, 처음 배울 때는 갑갑한 느낌이 듭니다.

이러한 관습에 빨리 익숙해지려면, 많이 찾아보고 사용해봐야합니다.

인터넷에서 pom.xml파일의 작성방법에 대해 조사해보세요.





## 2) Maven을 이용한 웹 어플리케이션 실습

### **학습 목표**

1. 메이븐을 이용해 웹 어플리케이션 프로젝트를 생성하고 설정할 수 있다.
2. 메이븐 프로젝트의 웹 어플리케이션을 실행할 수 있다.

### **핵심 개념**

- pom.xml
- project facet
- project properties menu

### **학습하기**

이번 시간에는 Maven을 이용해 웹 어플리케이션 프로젝트를 생성하고, 실행해보도록 하겠습니다.

이클립스를 실행하고, 이클립스의 메뉴 중 File - New - Project를 선택합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_93/15173903549717lnBe_PNG/maven01.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16724/#)

- 

  프로젝트 위자드(Wizard)가 뜨면, Maven아래의 Maven Project를 선택한 후 Next버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_271/1517390405142k98yp_PNG/maven02.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16724/#)

- 

  Maven프로젝트가 기존 워크스페이스 경로에 생성되도록 합니다. Next버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_237/15173904247979OJPr_PNG/maven03.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16724/#)

- 

  아키타입(Archetype)을 선택합니다. 아키타입이란 일종의 프로젝트 템플릿(Template)이라고 말할 수 있습니다. 어떤 아키타입을 선택했느냐에 따라서 자동으로, 여러 가지 파일들을 생성하거나 라이브러리를 셋팅해주거나 등의 일을 해줍니다. Maven을 이용하여 웹 어플리케이션을 개발하기 위해서 maven-archetype-webapp를 선택한 후 Next 버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_53/151739046174467lID_PNG/maven04.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16724/#)

- 

  Group Id는 보통 프로젝트를 진행하는 회사나 팀의 도메인 이름을 거꾸로 적습니다. Artifact Id는 해당 프로젝트의 이름을 적습니다. 버전은 보통 기본값(0.0.1-SNAPSHOT)으로 설정합니다. package이름은 group id와 Artifact Id가 조합된 이름이 됩니다. Group Id를 kr.or.connect이고 Artifact Id가 mavenweb으로 설정했기 때문에 package이름은 kr.or.connect.mavenweb이 됩니다. finish버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_216/1517390501234YqbJ4_PNG/maven05.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16724/#)

- 

  프로젝트가 생성된 프로젝트의 디렉토리 구조입니다. 디렉토리의 구조를 보기 위해서 이클립스의 Navigator view를 통해서 확인하였습니다. Maven으로 생성된 프로젝트의 경우 자바 소스는 src/main/java 폴더에 생성됩니다. 웹 어플리케이션과 관련된 html, css등은 src/main/webapp 폴더에서 작성해야 합니다. 그런데, 생성된 프로젝트를 보면 src/main/java 폴더가 보이지 않습니다. 필요한 폴더는 별도로 만들어줄 필요가 있습니다.

[![img](https://cphinf.pstatic.net/mooc/20180723_93/1532327705849hiuxX_PNG/_.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16724/#)

[![img](https://cphinf.pstatic.net/mooc/20180131_41/1517390521930voHdk_PNG/maven06.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16724/#)

[![img](https://cphinf.pstatic.net/mooc/20180131_252/1517390525001xoFVn_PNG/maven07.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16724/#)

- 

  프로젝트를 선택하고, 우측버튼을 눌러 properties를 선택합니다. 그리고, Java Compiler메뉴를 선택합니다. 선택을 해보면 기본적으로 JDK 1.5 버전을 사용하는 것을 알 수 있습니다. Maven으로 프로젝트를 생성하면 기본적으로 JDK 1.5를 사용하게 됩니다. JDK8을 사용하도록 하려면 Maven설정 파일인 pom.xml파일을 수정해야 합니다. pom.xml파일을 더블클릭하면 다음과 같이 보입니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_125/1517390594478q5Mvw_PNG/maven08.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16724/#)

- 

  아래쪽의 pom.xml 탭을 선택하면 소스가 보입니다.

```markup
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>kr.or.connect</groupId>
  <artifactId>mavenweb</artifactId>
  <packaging>war</packaging>
  <version>0.0.1-SNAPSHOT</version>
  <name>mavenweb Maven Webapp</name>
  <url>http://maven.apache.org</url>
  
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
  <build>
    <finalName>mavenweb</finalName>
  </build>
</project>
```

자동으로 juint 3.8.1 라이브러리를 추가하고 있습니다.

junit은 테스트를 위한 라이브러리입니다.

위의 내용에 다음의 코드를 입력합니다.

```markup
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>kr.or.connect</groupId>
  <artifactId>mavenweb</artifactId>
  <packaging>war</packaging>
  <version>0.0.1-SNAPSHOT</version>
  <name>mavenweb Maven Webapp</name>
  <url>http://maven.apache.org</url>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
  <build>
    <finalName>mavenweb</finalName>
        <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.6.1</version>
            <configuration>
                <source>1.8</source>
                <target>1.8</target>
            </configuration>
        </plugin>
    </plugins>
  </build>
</project>
```

코드를 입력하였으면, 저장합니다.

수정 후 다시 프로젝트 프로퍼티의 자바 컴파일러 항목을 보면 여전히 1.5 입니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_152/15173907953931jtNA_PNG/maven09.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16724/#)

- 

  프로젝트 프로퍼티를 선택한 후 Maven메뉴 아래의 Java EE Integration을 선택합니다. 보이는 것처럼 Enable Project Specific Settings 앞의 체크박스를 선택합니다. 그리고 아래의 Apply and Close버튼을 클릭합니다. 그리고, 다시 프로퍼티의 자바 컴파일러 버전을 확인하도록 하겠습니다. JDK 1.8이 사용되는 것을 알 수 있습니다. Maven의 설정을 바꾸면, 이클립스 프로젝트 설정이 연동되게 된 것입니다. 이번엔 webapp폴더 아래의 index.jsp를 열어보도록 하겠습니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_218/1517390838527L7N1g_PNG/maven10.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16724/#)

- 

  HttpServlet을 찾을 수 없다는 오류 메시지가 보입니다. 앞에서 Dynamic Web Application을 만들 때는 WAS Runtime설정을 하면서 Tomcat을 지정했었습니다. WAS Runtime이 지정되면 Tomcat에 있는 라이브러리를 이클립스에서 사용할 수 있게 됩니다. Tomcat안에 있는 서블릿 라이브러리가 사용되면서 문제가 없게 됩니다. 실행시에도 WAS 위에서 실행되기 때문에 WAS의 서블릿 라이브러리를 사용하게 됩니다. Maven프로젝트로 생성했을 경우에는 WAS 런타임이 지정을 안 했기 때문에 서블릿 라이브러리를 찾을 수 없습니다. dependencies 엘리먼트 아래에 다음을 추가합니다.

```markup
<dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>3.1.0</version>
        <scope>provided</scope>
    </dependency>
```

위의 내용을 보면 scope에 provided라는 항목이 있는데 servlet라이브러리를 컴파일 시에만 사용되고 배포 시에는 사용되지 않는다는 것을 의미합니다.

scope는 다음과 같은 4가지가 있습니다.

- **compile** : 컴파일 할 때 필요. 테스트 및 런타임에도 클래스 패스에 포함됩니다. scope 을 설정하지 않는 경우 기본값입니다.
- **runtime** : 런타임에 필요. JDBC 드라이버 등이 예가 됩니다. 컴파일 시에는 필요하지 않지만, 실행 시에 필요한 경우입니다.
- **provided** : 컴파일 시에 필요하지만, 실제 런타임 때에는 컨테이너 같은 것에서 제공되는 모듈. servlet, jsp api 등이 이에 해당. 배포 시 제외됩니다. 
- **test** : 테스트 코드를 컴파일 할 때 필요. 테스트 시 클래스 패스에 포함되며, 배포 시 제외됩니다.

위의 내용을 추가하고 index.html을 가보면 오류가 발생하지 않는 것을 알 수 있습니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_230/1517390978066hU3Kl_PNG/maven11.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16724/#)

- 

  해당 프로젝트를 실행해 보도록 하겠습니다. 프로젝트를 선택한 후 우측버튼을 클릭하여 Run on Server를 선택합니다. 해당 웹 어플리케이션을 실행할 Runtime을 지정하고, 항상 해당 런타임을 사용하겠다는 아래쪽 체크박스도 선택한 후 Finish버튼을 클릭합니다.

[![img](https://cphinf.pstatic.net/mooc/20180131_294/1517391005231cu2Kq_PNG/maven12.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16724/#)

- 

  브라우저가 실행되면서 index.html이 보여지는 것을 확인할 수 있습니다. 이번엔 pom.xml 파일에 JSTL라이브러리를 추가하도록 하겠습니다.

```markup
<dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>jstl</artifactId>
        <version>1.2</version>
    </dependency>
```

JSTL은 Tomcat이 기본으로 제공하지 않기 때문에, 컴파일할 때도 배포할 때도 사용돼야 합니다.

그래서 scope에 이번엔 provided가 있지 않습니다.

webapp폴더에 앞에서 작성했던 jstl02.jsp 를 붙여넣기를 하도록 하겠습니다.

라이브러리가 변경되었으니, 다시 run on server를 합니다.

실행해도 결과가 아무것도 나오지 않는 것을 확인할 수 있습니다.

프로젝트 프로퍼티를 선택한 후, Project facets 항목을 보면 다이나믹 웹 모듈의 버전이 2.3입니다.

다이나믹 웹 모듈의 2.4부터 EL이 기본으로 사용할 수 있도록 설정되기 때문에 2.3일 경우에는 EL표기법의 결과가 출력되지 않습니다.

앞의 프로젝트처럼 다이나믹 웹 모듈 3.1이 되도록 설정해보도록 하겠습니다.

먼저 WEB-INF의 web.xml 파일을 열어보도록 하겠습니다.

```markup
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
  <display-name>Archetype Created Web Application</display-name>
</web-app>
```

위의 내용을 다음과 같이 수정합니다.

```markup
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1">
  <display-name>Archetype Created Web Application</display-name>
</web-app>
```

프로젝트아래의 .settings/org.eclipse.wst.common.project.facet.core.xml 파일을 엽니다.

이클립스 navigator에서 보면 보입니다.

```markup
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <fixed facet="wst.jsdt.web"/>
  <installed facet="jst.web" version="2.3"/>
  <installed facet="wst.jsdt.web" version="1.0"/>
  <installed facet="java" version="1.8"/>
</faceted-project>
```

을 아래와 같이 수정합니다.

```markup
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <fixed facet="wst.jsdt.web"/>
  <installed facet="jst.web" version="3.1"/>
  <installed facet="wst.jsdt.web" version="1.0"/>
  <installed facet="java" version="1.8"/>
</faceted-project>
```

프로젝트 프로퍼티의 Project facets항목을 보면 다이나믹 웹 모듈이 3.1로 바뀐 것을 볼 수 있습니다.

이제 jstl02.jsp를 run on server로 실행합니다.

실행을 하지만 오류가 나면서 실행이 안 되는 경우가 있을 수 있습니다.

이클립스의 버그로, 수정되기 전의 데이터와 수정된 데이터가 섞여서 실행되기 때문입니다.

이 경우 웹 어플리케이션을 깔끔히 초기화하고 실행하는 것이 좋을 수 있습니다.

1. 기존 tomcat을 종료합니다.
2. 혹시 바뀌지 않았다면 프로젝트를 선택하고, 우측버튼을 눌러서 Maven 메뉴 아래의 update project를 선택한 후 확인하세요.
3. Servers view에서 기존 Tomcat Runtime을 삭제
4. Project 메뉴의 Clean선택
5. 프로젝트 익스플로러에서 Server 삭제

위와 같은 과정을 거친 후 Run on Server로 실행해보세요.

결과가 잘 나오는 것을 확인할 수 있습니다.

지금까지 배웠던 내용 중에서 가장 복잡한 것 같은데요.

다이나믹 웹 모듈을 2.3에서 3.1로 바꾸는 것은 프로젝트가 한번 만들어지면, 그 이후부터는 그 프로젝트가 더 이상 사용되지 않을 때까지 계속 사용되기 때문에 자주 개발자가 해야 할 일은 아닙니다.

그 이후부터는 pom.xml에 원하는 기능을 추가하면서 개발을 진행하면 됩니다.

수고하셨습니다.



### **생각해보기**

1. 이클립스에는 Maven이 내장되어 있습니다. 이번 시간엔 이클립스에 내장된 Maven을 이용해 프로젝트를 생성해보았습니다. cmd창이나 터미널에서 maven명령을 수행해서 컴파일하고 실행할 수도 있습니다. 이를 위해선 Maven을 별도로 설치를 해야 합니다. Maven을 설치하고, 콘솔이나 터미널에서 실행할 방법을 찾아보세요.



# 10. JDBC - BE

## 1) JDBC란?

### **학습 목표**

1. JDBC가 무엇인지 이해한다.

### **핵심 개념**

- JDBC
- DriverManager
- Connection
- Statement
- ResultSet

### 학습하기

**JDBC 개요**

- JDBC(Java Database Connectivity)의 정의
  - 자바를 이용한 데이터베이스 접속과 SQL 문장의 실행, 그리고 실행 결과로 얻어진 데이터의 핸들링을 제공하는 방법과 절차에 관한 규약
  - 자바 프로그램 내에서 SQL문을 실행하기 위한 자바 API
  - SQL과 프로그래밍 언어의 통합 접근 중 한 형태
- JAVA는 표준 인터페이스인 JDBC API를 제공
- 데이터베이스 벤더, 또는 기타 써드파티에서는 JDBC 인터페이스를 구현한 드라이버(driver)를 제공한다.



**JDBC 환경 구성**

- JDK 설치
- JDBC 드라이버 설치
  \- Maven에 다음과 같은 의존성을 추가한다. MySQL사이트에서 다운로드 한다.

```xml
<dependency>   
    <groupId>mysql</groupId>   
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.45</version>
</dependency>
```

- [Java API Reference 참고 바로가기](https://docs.oracle.com/javase/8/docs/api/)
- [JDBC Tutorial 참고 바로가기](https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html)



**JDBC를 이용한 프로그래밍 방법**

1. import java.sql.*;
2. 드라이버를 로드 한다.
3. Connection 객체를 생성한다.
4. Statement 객체를 생성 및 질의 수행
5. SQL문에 결과물이 있다면 ResultSet 객체를 생성한다.
6. 모든 객체를 닫는다.



**JDBC 클래스의 생성 관계**

[![img](https://cphinf.pstatic.net/mooc/20180201_49/1517475141729UGWfv_PNG/2_11_1_JDBC_.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16734/#)

- **JDBC클래스의 생성단계**
- 연결 해제는 생성의 역순

**JDBC 사용 - 단계별 설명**

1. IMPORT

```java
import java.sql.*;
```

 

2. 드라이버 로드

```java
Class.forName( "com.mysql.jdbc.Driver" );
```

 

3. Connection 얻기

```java
String dburl  = "jdbc:mysql://localhost/dbName";

Connection con =  DriverManager.getConnection ( dburl, ID, PWD );
```

 

소스코드 예제

```java
public static Connection getConnection() throws Exception{
	String url = "jdbc:oracle:thin:@117.16.46.111:1521:xe";
	String user = "smu";
	String password = "smu";
	Connection conn = null;
	Class.forName("oracle.jdbc.driver.OracleDriver");
	conn = DriverManager.getConnection(url, user, password);
	return conn;
}
```

 

4. Statement 생성

```java
Statement stmt = con.createStatement();
```

 

5. 질의 수행

```java
ResultSet rs = stmt.executeQuery("select no from user" );

참고
stmt.execute(“query”);         //any SQL
stmt.executeQuery(“query”);    //SELECT
stmt.executeUpdate(“query”);   //INSERT, UPDATE, DELETE
```

 

6. ResultSet으로 결과 받기

```java
ResultSet rs =  stmt.executeQuery( "select no from user" );
while ( rs.next() )
      System.out.println( rs.getInt( "no") );
```

 

7. Close

```java
rs.close();

stmt.close();

con.close();
```

 

소스코드 예제

```java
public List<GuestBookVO> getGuestBookList(){
		List<GuestBookVO> list = new ArrayList<>();
		GuestBookVO vo = null;
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
		try{
			conn = DBUtil.getConnection();
			String sql = "select * from guestbook";
			ps = conn.prepareStatement(sql);
			rs = ps.executeQuery();
			while(rs.next()){
				vo = new GuestBookVO();
				vo.setNo(rs.getInt(1));
				vo.setId(rs.getString(2));
				vo.setTitle(rs.getString(3));
				vo.setConetnt(rs.getString(4));
				vo.setRegDate(rs.getString(5));
				list.add(vo);
			}
		}catch(Exception e){
			e.printStackTrace();
		}finally {
			DBUtil.close(conn, ps, rs);
		}		
		return list;		
	}
```

 

소스코드 예제

```java
public int addGuestBook(GuestBookVO vo){
		int result = 0;
		Connection conn = null;
		PreparedStatement ps = null;
		try{
			conn = DBUtil.getConnection();
			String sql = "insert into guestbook values("
					+ "guestbook_seq.nextval,?,?,?,sysdate)";
			ps = conn.prepareStatement(sql);
			ps.setString(1, vo.getId());
			ps.setString(2, vo.getTitle());
			ps.setString(3, vo.getConetnt());
			result = ps.executeUpdate();
		}catch(Exception e){
			e.printStackTrace();
		}finally {
			DBUtil.close(conn, ps);
		}
		
		return result;
	}
```

 

소스코드 예제

```java
public static void close(Connection conn, PreparedStatement ps){
		if (ps != null) {
			try {
				ps.close();
			} catch (SQLException e) {e.printStackTrace(); }
		}
		if (conn != null) {
			try {
				conn.close();
			} catch (SQLException e) {e.printStackTrace();}
		}
	}
```



### **생각해보기**

java.sql패키지를 보면 대부분이 interface로 되어 있는 것을 알 수 있습니다.

이를 실제로 구현하는 것은 DBMS를 만든 회사입니다.

java.sql외에 JAVA가 인터페이스만 대부분 제공하는 패키지는 또 어떤 것이 있을까요?

참고로 XML문서의 표준은 w3c에서 정합니다.

## 2) JDBC 실습

### **학습 목표**

1. JDBC를 이용해 입력/수정/삭제/조회 프로그래밍을 할 수 있다.

### **핵심 개념**

- JDBC
- PreparedStatement
- ResultSet
- Connection

### **생각해보기**

1.  JDBC를 이용해서 입력/수정/삭제/조회 메소드를 만들다 보면, 반복적인 코드가 많다는 것을 알 수 있습니다.반복되는 부분을 별도의 메서드나 클래스로 추출한다면 어떤 부분의 중복을 제거할수 있을까요?
2.  JDK7부터 추가된 try-with-resource 구문을 이용한다면 예제 코드 중 어떤 부분을 줄일 수 있을까요?

# 11. WEB API - BE

## 1) Rest API란?

### **학습 목표**

1. REST API가 무엇인지 이해합니다.
2. WEB API(HTTP API)와 REST API를 구분할 수 있습니다.

### **핵심 개념**

- REST API
- WEB API (HTTP API)

### **학습하기**

**API란?**

API는 Application Programming Interface의 약자입니다.

wiki를 보면 API에 대한 설명이 다음과 같이 되어 있습니다.

“API(Application Programming Interface, 응용 프로그램 프로그래밍 인터페이스)는 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻합니다.

주로 파일 제어, 창 제어, 화상 처리, 문자 제어 등을 위한 인터페이스를 제공합니다.

설명만 봐서는 어떤 뜻인지 이해하기 어렵네요.

이번엔 다음의 URL주소를 보도록 하겠습니다.

[참고 바로가기](https://docs.oracle.com/javase/8/docs/api/)

위의 URL주소를 가면 java 8의 API문서를 볼 수 있습니다.

자바 언어가 제공하는 클래스와 인터페이스에 대한 설명이 API문서입니다. 

자바 프로그래밍을 위해서는 자바 언어가 제공하는 것들이 어떤 것이 있는지를 알아야 합니다.

그래야, 사용할 수 있겠죠?

절대값을 구하기 위해서는 어떻게 해야 할까요?

Java API문서를 읽어보면 답을 알 수 있습니다.

Math클래스의 abs()메소드를 사용하면 된다는 것을 알 수 있죠.

해당 메소드가 어떻게 내부적으로 구현되어 있는지는 문서를 봐도 알 수 없습니다.

하지만, 해당 라이브러리를 사용할 때 구현코드를 알지 못해도 인터페이스만 알면 사용할 수 있습니다.

이렇게 프로그래밍을 할 때 필요한 인터페이스를 API라고 합니다.



**REST API란?**

REST는 REpresentational State Transfer라는 용어의 약자로서 2000년도에 로이 필딩 (Roy Fielding)의 박사학위 논문에서 최초로 소개되었습니다.

REST API란 말 그대로 REST형식의 API를 말합니다. 

REST API란 핵심 컨텐츠 및 기능을 외부 사이트에서 활용할 수 있도록 제공되는 인터페이스입니다.

예를 들어, 네이버에서 블로그에 글을 저장하거나, 글 목록을 읽어갈 수 있도록 외부에 기능을 제공하거나 우체국에서 우편번호를 조회할 수 있는 기능을 제공하거나, 구글에서 구글 지도를 사용할 수 있도록 제공하는 것들을 말합니다.

[![img](https://cphinf.pstatic.net/mooc/20180206_20/1517901229093n4XI7_PNG/001.png?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16740/#)

- **REST API**

웹 브라우저 뿐만 아니라 앱 등 다양한 클라이언트가 등장하면서 그러한 클라이언트들에게 대응하기 위해 REST API가 널리 사용되기 시작하였습니다.

서비스 업체들이 다양한 REST API를 제공함으로써, 클라이언트는 이러한 REST API들을 조합한 어플리케이션을 만들 수 있게 되었습니다.

이를 매시업(Mashup)이라고 합니다.

다음은 유명 사이트에서 제공하는 API 관련된 문서 링크입니다.

- [네이버 API 소개 바로가기](https://developers.naver.com/products/intro/plan/)
- [페이스북의 그래프 API 문서 바로가기](https://developers.facebook.com/docs/graph-api)
- [공공 데이터 포털 바로가기](https://www.data.go.kr/)



**이것은 REST가 아니다.**

이렇게 REST API가 널리 사용되었지만, REST를 논문으로 최초 소개한 로이필딩은 대부분의 REST API라고 하는 것들이 REST API가 아니라고 말합니다.

REST는 다음과 같은 스타일을 반드시 지켜야 한다고 말합니다.

- client-server
- stateless
- cache
- uniform interface
- layered system
- code-on-demand (optional)

여기서 스타일이란 제약조건의 집합을 의미합니다.

즉, 위에서 언급한 내용을 잘 지켜야만 REST라고 말할 수 있다는 의미입니다.

HTTP프로토콜을 사용한다면 client-server, stateless, cache, lared system, code-on-demand 등에 대해서는 모두 쉽게 구현 가능합니다.

하지만, 문제는 uniform interface입니다.

uniform interface의 스타일

- 리소스가 URI로 식별되야 합니다.
- 리소스를 생성,수정,추가하고자 할 때 HTTP메시지에 표현을 해서 전송해야 합니다.
- 메시지는 스스로 설명할 수 있어야 합니다. (Self-descriptive message)
- 애플리케이션의 상태는 Hyperlink를 이용해 전이되야 합니다.(HATEOAS)

첫 번째와 두 번째 항목은 지키기 어렵지 않은데, 메시지가 스스로 설명할 수 있어야 하는 부분과 HATEOAS를 지원하는 것은 웹과는 다르게 API로는 쉽지가 않습니다.

응답 결과에 보통 JSON 메시지(다음 시간에 간단히 다루게 됩니다.)를 사용하게 되는데, 이 JSON메시지가 어디에 전달되는지 그리고 JSON메시지를 구성하는 것이 어떤 의미를 표현해야만 메시지 스스로 설명할 수 있다고 말할 수 있는데, 그게 쉽지 않습니다.

우리가 웹 게시판을 사용할 때, 리스트 보기를 보면, 상세보기나 글쓰기로 이동할 수 있는 링크가 있습니다.

상세보기에서는 글 수정이나 글 삭제로 갈 수 있는 링크가 있습니다.

이렇게 웹 페이지를 보면, 웹 페이지 자체에 관련된 링크가 있는것을 알 수 있는데 이를 HATEOAS라고 말합니다.

이런 HATEOAS를 API에서 제공하는 것은 쉽지 않습니다.



**REST API는 쉽지 않다. 그래서, 보통은 Web API(혹은 HTTP API)를 사용한다.**

REST의 uniform interface를 지원하는 것은 쉽지 않기 때문에, 많은 서비스가 REST에서 바라는 것을 모두 지원하지 않고 API를 만들게 됩니다.

- REST의 모든 것을 제공하지 않으면서 REST API라고 말하는 경우도 있습니다.
- REST의 모든 것을 제공하지 않고 Web API 혹은 HTTP API라고 부르는 경우가 있습니다.

우리는 2번째 방식을 따르려고 합니다.

이번 시간엔 REST API가 무엇인지 개념을 살펴봤습니다.

다음 시간에는 Web API에 대해서 알아보고 실습도 해보도록 하겠습니다.



### **생각해보기**

1. 이번 시간엔 Rest API라는 용어에 대해 살펴보았습니다. REST에서 몇가지 규칙을 지키지 않을 경우 Web API혹은 HTTP API라고 부르기로 하였습니다. 프로그래밍을 공부하다보면 용어에 대해 굉장히 깐깐히 다루는 것을 종종 목격하게 됩니다. 용어에 대해서 명확하게 정의하지 않을 경우 어떤 일이 발생할까요?



## 2) Web API란?

### **학습 목표**

1. REST API와 Web API의 차이에 대해 이해합니다.
2. Web API의 디자인 가이드에 대해 이해합니다.

### **핵심 개념**

- Web API
- HTTP Methods

### **학습하기**

**Web API 디자인 가이드**

- URI는 정보의 자원을 표현해야 합니다.
- 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현합니다.

 

**자원에 대한 행위는 HTTP Method로 표현**

[![img](https://cphinf.pstatic.net/mooc/20180206_109/1517904573515UkVsl_PNG/2_11_2_webapi.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16741/#)

- **Web API**

**URI는 정보의 자원을 표현해야 한다.**

- GET /members
  : 위의 표현은 맴버의 모든 정보를 달라는 요청입니다.
- GET /members/delete/1
  : GET은 정보를 요청할 때 사용합니다. 위와 같이 동사로 삭제를 표현하면 안 됩니다.
- DELETE /members/1
  : HTTP Method 중의 하나인 DELETE를 이용하여 삭제를 표현해야 합니다.

 

**자원에 대한 행위는 HTTP Method로 표현**

- GET /members/1          (o)
- GET /members/get/1       (x)
- GET /members/add         (x)
- POST /members            (o)
- GET /members/update/1    (x)
- PUT /members/1           (o)
- GET /members/del/1        (x)
- DELETE /members/1        (o)



**슬래시 구분자(/)는 계층을 나타낼 때 사용**

http://domain/houses/apartments

http://domain/departments/1/employees

- URI 마지막 문자로 슬래시 구분자(/)를 포함하지 않습니다.
- 하이픈(-)은 URI가독성을 높일 때 사용합니다.
- 언더바(_)는 사용하지 않습니다.
- URI경로는 소문자만 사용합니다.
- RFC 3986(URI 문법 형식)은 URI스키마와 호스트를 제외하고는 대소문자를 구별합니다.
- 파일 확장자는 URI에 포함하지 않습니다.
- Accept Header를 사용합니다.

 



**상태 코드 (성공)**

[![img](https://cphinf.pstatic.net/mooc/20180206_273/1517904784161eGNFk_PNG/2_11_1_1.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16741/#)

상태 코드 (성공)

**상태 코드 (클라이언트로 인한 오류)**

[![img](https://cphinf.pstatic.net/mooc/20180206_113/1517904803278oyxuH_PNG/2_11_1_2.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16741/#)

상태 코드 (클라이언트로 인한 오류)

**상태 코드 (서버로 인한 오류)**

[![img](https://cphinf.pstatic.net/mooc/20180206_194/1517904834300fxqr9_PNG/2_11_1_3.PNG?type=w760)](https://www.edwith.org/boostcourse-web/lecture/16741/#)

상태 코드 (서버로 인한 오류)



### **생각해보기**

1. 기계와 기계가 통신하는 방법 중에 web API가 있습니다. 이 외에 또 어떤 방법으로 기계와 기계가 통신할 수 있을까요?

## 3) Web API 실습

### **학습 목표**

1. Servlet을 이용해 Web API를 작성할 수 있습니다.
2. 객체를 JSON문자열로 변환시킬 수 있습니다.

### **핵심 개념**

- JSON
- ObjectMapper
- URL pattern에서 wildcard(*)

### **실습코드**

- 모든 롤 정보 읽어오기. GET /roles
- 특정한 롤정보 읽어오기. GET /roles/{roleId}
- 롤정보 등록하기. POST /roles
- 롤정보 삭제하기. DELETE /roles/{roleId}
- 롤정보 수정하기. PUT /roles/{roleId}



pom.xml

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>kr.or.connect</groupId>
	<artifactId>webapiexam</artifactId>
	<packaging>war</packaging>
	<version>0.0.1-SNAPSHOT</version>
	<name>webapiexam Maven Webapp</name>
	<url>http://maven.apache.org</url>
	<properties>
		<!-- web.xml 파일을 삭제해도 eclipse에서 오류가 발생하지 않는다. -->
		<failOnMissingWebXml>false</failOnMissingWebXml>
	</properties>
	<dependencies>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.45</version>
		</dependency>

		<!-- json 라이브러리 databind jackson-core, jackson-annotaion에 의존성이 있다. -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.9.4</version>
		</dependency>

		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
		</dependency>

		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>

		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>3.8.1</version>
			<scope>test</scope>
		</dependency>
	</dependencies>
	<build>
		<finalName>webapiexam</finalName>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.6.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>
```



RoleServlet.java

```java
package kr.or.connect.webapiexam.api;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.fasterxml.jackson.databind.ObjectMapper;

import kr.or.connect.jdbcexam.dao.RoleDao;
import kr.or.connect.jdbcexam.dto.Role;

@WebServlet("/roles")
public class RolesServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	public RolesServlet() {
		super();
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.setCharacterEncoding("utf-8");
		response.setContentType("application/json");

		RoleDao dao = new RoleDao();

		List<Role> list = dao.getRoles();

		ObjectMapper objectMapper = new ObjectMapper();
		String json = objectMapper.writeValueAsString(list);

		PrintWriter out = response.getWriter();
		out.println(json);
		out.close();
	}

}
```

application/json IE8,9 에서 인식안되서 파일 저장으로 나오는 문제에 대한 해결 [바로가기](https://blog.asamaru.net/2016/02/23/jquery-ajax-ie8-content-type-application-json/)



### **실습코드**

RoleByIdServlet.java

```java
package kr.or.connect.webapiexam.api;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.fasterxml.jackson.databind.ObjectMapper;

import kr.or.connect.jdbcexam.dao.RoleDao;
import kr.or.connect.jdbcexam.dto.Role;

@WebServlet("/roles/*")
public class RoleByIdServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	public RoleByIdServlet() {
		super();
		// TODO Auto-generated constructor stub
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.setCharacterEncoding("utf-8");
		response.setContentType("application/json");

		String pathInfo = request.getPathInfo(); // /roles/{roleId}
		String[] pathParts = pathInfo.split("/");
		String idStr = pathParts[1];
		int id = Integer.parseInt(idStr);

		RoleDao dao = new RoleDao();

		Role role = dao.getRole(id);

		ObjectMapper objectMapper = new ObjectMapper();
		String json = objectMapper.writeValueAsString(role);

		PrintWriter out = response.getWriter();
		out.println(json);
		out.close();
	}

}
```



### **생각해보기**

자바 서블릿은 보통 하나의 URL에 대한 처리만 합니다.

그런데 이번 실습을 보면 Role과 관련된 다양한 URL이 필요했고, 이를 처리하기 위한 클래스가 여러 개 필요했습니다.

객체지향은 관련된 여러 개의 기능을 하나로 모으는 것이 중요합니다.

그런데, 관련된 여러 개의 URL 처리를 여러 개의 서블릿으로 나눠서 하고 있습니다.

이러한 문제를 해결하려면 어떻게 해야 할까요?





# 12. Summary

## 내용 정리

#### Frontend

- JavaScript 이해, 특히 함수의 특징
  1. 기초 문법
     1. for문, 조건문
  2. 함수
     1. 표현 방법
     2. 반환 방식
     3. 매개변수 사용법
     4. 함수를 적절하게 분리

- 웹 프론트엔드의 기본기 삼총사의 원리 이해
  - DOM
    1. QuerySelector
  - Event
  - Ajax
    1. 역할, 사용법

#### Backend

- JSP

  Servlet 뒤에 나온 기술이므로 적절히 혼용하면 효과적이다

  Servlet이 비즈니스 로직 수행

  JSP는 출력용

  결과 넘겨줄때는 forward

  URL 변경할때는 redirect

- JSTL & EL

  JSP에서 결과 출력 시에 사용

- MySQL & SQL
- Maven





## PJT2_Todo

### Frontend

- 할일 목록, 할일 등록 화면
- CSS 똑같이
- 글자의 크기는 일정한 수준을 유지
- CSS는 외부 라이브러리를 사용하지 않음
- jQuery를 사용하지 않고 querySelector, addEventListener, innerHTML을 사용해서 DOM, Event 처리
- Ajax는 XMLHTTPRequest 사용

### Backend

- maven 프로젝트 생성
- 테이블 생성 SQL 사용
- TodoDto, TodoDao 클래스
- MainServlet, main.jsp
  - TodoDao를 통해 결과 조회 -> main.jsp 에 전달
- 새운 todo 등록 시 해당 servlet이 받아서 jsp로 forwarding
- 할일 등록 폼에서 제출하면 post 방식으로 요청, 해당 servlet이 받아서 처리하고 메인화면으로 리다이렉트
- todo 상태변경(->) 클릭 시 todo id와 상태값 전달해 다음 상태로 변경하고 응답결과로 success

